:sectnums:
:toc: left

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;


[[riscv-doc-template]]
= Advanced Core-Local Interrupt Controller (ACLIC) RISC-V Privileged Architecture Extensions
include::../docs-resources/global-config.adoc[]
:docgroup: RISC-V Task Group
:description: RISC-V Example Specification Document (Zexmpl)
:revdate: current
:revnumber: dev
:revremark: This document is under development. Expect potential changes. Visit http://riscv.org/spec-state for further details.
:revinfo:
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
// https://docs.asciidoctor.org/asciidoc/latest/macros/images-directory/
:imagesdir: ../docs-resources/images
:title-logo-image: image:risc-v_logo.png["RISC-V International Logo",pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
//:srcdir: src
:bibtex-file: src/example.bib
:bibtex-order: alphabetical
:bibtex-style: apa
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short


Graphics used are either explicitly available for free, are the property of RISC-V International, or were created using Wavedrom.

:xstatus: pass:q[``xstatus``]
:status: pass:q[``**__x__**status``]
:ideleg: pass:q[``**__x__**ideleg``]
:ie: pass:q[``**__x__**ie``]
:tvec: pass:q[``**__x__**tvec``]
:ivt: pass:q[``**__x__**ivt``]
:xivt: pass:q[``xivt``]
:EHV: pass:q[``EHV``]
:xeivt: pass:q[``xeivt``]
:xtvec: pass:q[``xtvec``]
:xepc: pass:q[``xepc``]
:xsp: pass:q[``xsp``]
:scratch: pass:q[``**__x__**scratch``]
:scratchcsw: pass:q[``**__x__**scratchcsw``]
:scratchcswl: pass:q[``**__x__**scratchcswl``]
:epc: pass:q[``**__x__**epc``]
:cause: pass:q[``**__x__**cause``]
:tval: pass:q[``**__x__**tval``]
:ip: pass:q[``**__x__**ip``]
:pistatus: pass:q[``**__x__**pistatus``]
:xpistatus: pass:q[``xpistatus``]
:pithreshold: pass:q[``pithreshold``]
:mithreshold: pass:q[``mithreshold``]
:sithreshold: pass:q[``sithreshold``]
:xithreshold: pass:q[``xithreshold``]

:eidelivery: pass:q[``eidelivery``]
:eithreshold: pass:q[``eithreshold``]
:eipk: pass:q[``eip__k__``]
:eiek: pass:q[``eie__k__``]
:setie: pass:q[``setie``]
:setip: pass:q[``setip``]
:clrie: pass:q[``clrie``]
:in_clrip: pass:q[``in_clrip``]
:ithreshold: pass:q[``ithreshold``]
:xtopei: pass:q[``xtopei``]
:topi: pass:q[``topi``]
:vstopei: pass:q[``vstopei``]
:xtopi: pass:q[``xtopi``]
:xtopei: pass:q[``xtopei``]
:claimi: pass:q[``claimi``]

:mstatus: pass:q[``mstatus``]
:mideleg: pass:q[``mideleg``]
:mie: pass:q[``mie``]
:mtvec: pass:q[``mtvec``]
:mivt: pass:q[``mivt``]
:meivt: pass:q[``meivt``]
:mscratch: pass:q[``mscratch``]
:msp: pass:q[``msp``]
:mepc: pass:q[``mepc``]
:mnepc: pass:q[``mnepc``]
:mcause: pass:q[``mcause``]
:mtval: pass:q[``mtval``]
:mip: pass:q[``mip``]
:mpistatus: pass:q[``mpistatus``]
:mpnipprio: pass:q[``mpnipprio``]
:mistatus: pass:q[``mistatus``]
:mipreemptcfg: pass:q[``mipreemptcfg``]
:preemptmsk: pass:q[``preemptmsk``]
:mintthresh: pass:q[``mintthresh``]
:mtopi: pass:q[``mtopi``]
:mclaimi: pass:q[``mclaimi``]

:sstatus: pass:q[``sstatus``]
:sideleg: pass:q[``sideleg``]
:sie: pass:q[``sie``]
:stvec: pass:q[``stvec``]
:sivt: pass:q[``sivt``]
:sscratch: pass:q[``sscratch``]
:ssp: pass:q[``ssp``]
:sepc: pass:q[``sepc``]
:scause: pass:q[``scause``]
:stval: pass:q[``stval``]
:sip: pass:q[``sip``]
:spistatus: pass:q[``spistatus``]
:spnipprio: pass:q[``spnipprio``]
:snipprio: pass:q[``snipprio``]
:sintthresh: pass:q[``sintthresh``]
:stopi: pass:q[``stopi``]
:sclaimi: pass:q[``sclaimi``]

:pp: pass:q[``**__x__**pp``]
:xpp: pass:q[``xpp``]
:pie: pass:q[``**__x__**pie``]

:mpp: pass:q[``mpp``]
:mpie: pass:q[``mpie``]

:ret: pass:q[``**__x__**ret``]
:mret: pass:q[``mret``]
:sret: pass:q[``sret``]
:xret: pass:q[``xret``]
:xipopret: pass:q[``xipopret``]

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;

// SPDX-License-Identifier: CC-BY-4.0
//
// licensing.adoc: licensing information
//
// Copyright and licensing information for the specification.
//

[Preface]
== Copyright and license information

This RISC-V ACLIC extension specification is Â© 2018-2025 RISC-V international

This document is released under a Creative Commons Attribution 4.0
International License. +
https://creativecommons.org/licenses/by/4.0/.

== Introduction

The set of extensions defined in this specification enhance the existing interrupt specifications.
The Advanced Core Local Interrupt Controller (ACLIC) is a single hart interrupt controller defined for:

  * Low latency interrupt handling (achieved through nested preemption)
  * High throughput interrupt handling
  * Up to 1023 external interrupts
  * Low area overhead
  * Maximize compatibility with AIA

The table below provides a summary of the ACLIC extensions.

[%autowidth]
|===
| Extension Name | Description
| Smidctrl     | Interrupt domain control interface at Machine level
| Ssidctrl     | Interrupt domain control interface at Supervisor level
| Smivt        | Support for interrupt vector table at Machine level
| Ssivt        | Support for interrupt vector table at Supervisor level
| Smehv        | Synchronous exception hardware vectoring at Machine level
| Ssehv        | Synchronous exception hardware vectoring at Supervisor level
| Smcsps       | Conditional stack pointer swap at Machine level
| Sscsps       | Conditional stack pointer swap at Supervisor level
| Smnip        | Horizontal Nested Interrupt Preemption support at Machine level
| Ssnip        | Horizontal Nested Interrupt Preemption support at Supervisor level
| Smip         | Support for interrupt handler push/pop at Machine level
| Ssip         | Support for interrupt handler push/pop at Supervisor level
|===

As this specification aims for single-hart systems, no support for the H extension is foreseen.
Future specifications could extend the scope of these extensions to also be applicable to systems with the H extension.

NOTE: The extensions defined here are orthogonal to the NMI and RNMI
mechanisms. Their behavior is unchanged by the extensions of ACLIC.

== Fundamental components of ACLIC

This section lays the foundation for fast interrupt handling,
by providing a simple interrupt controller addressing the following goals:

  * Up to 1023 external interrupts
  * Low area overhead
  * Maximize compatibility with AIA

To achieve this, it builds upon the hart-level extensions of AIA,
and integrates a subset of Advanced Platform Level Interrupt Controller (APLIC) functionality into a hart-local interrupt controller.

In terms of compatibility, the goal is that a hart
can be used with the same trap handlers as one developed for AIA.

At config-time, the interface differs from AIA,
but the same structures for configuration as in the APLIC are used.

An ACLIC is made up of two major components:

. Hart-local APLIC domains providing direct delivery of interrupts to the hart (Non-ISA)
. Indirect CSR physical control interface to hart-local APLIC domain registers (Smidctrl, Ssidctrl)

The latter is additionally made up of

. Interrupt control interface for pending and enable bits based on IMSIC
. New indirect CSRs for accessing the remaining state of the hart-local APLIC domains

=== Hart-local APLIC domains (Non-ISA)

The APLIC was designed as a multi-hart interrupt controller.
Here, APLIC domains are used tightly coupled with a single hart.
The domains used here are a simplified subset of the full domain definition of the APLIC.

==== Interrupt domain mapping

An APLIC has one or more interrupt domains,
each associated with a subset of RISC-V harts at one privilege level.

An ACLIC system requires at most two domains.
It only requires one domain if M-mode but not S-mode has been implemented,
and two domains if M- and S-mode are implemented.

The root domain is always at machine level.
If supervisor level is implemented,
interrupts can be delegated to a supervisor-level domain,
which is the only child domain (Child Index '0') of the root domain.

==== Simplifications to domain state

The APLIC contains a per-domain configuration register,
which, among other things, allows selecting the delivery mode.

In an ACLIC system, `DM` is fixed to 0 (direct delivery mode).

The following, additional restrictions are applied:

[%autowidth,float="center",align="center",cols="<,<",grid=none,frame=none]
|===
|bits 31:24 |read-only 0x80 
|bit 8|IE = 1 (read-only)
|bit 7|read-only 0
|bit 2 |DM = 0
|===

The `IE` bit is fixed to 1, as its functionality is subsumed by the {xstatus}.`xIE` bits at the hart.
The `BE` bit is now reserved.
Endianness is controlled exclusively by the setting in the {xstatus} register at the hart.

Further simplifications are:

* The Child Index field in the sourcecfg[i] register is always '0' when D=1 (i.e. delegation to child domain). This is only possible in Machine mode. In Supervisor mode, D=0, as there is no child domain.
* As the ACLIC operation is based on direct interrupt delivery, xmsiaddrcfg[h] and genmsi registers are not required.
* Interrupt delivery control (IDC) structures are not needed, as the domain has a fixed relationship with one hart, and IDC functionality is already provided by hart-local CSRs.
* The hart index inside the target registers is read-only zero, as only one hart is supported.

APLIC registers or fields not required here shall be read-only zero.

==== Interrupt delivery

The APLIC rules of direct interrupt delivery apply.
External interrupt signals are supplied to the hart from the respective domain.
The interrupts from the root domain appear as MEIP (Machine External Interrupt-Pending),
and interrupts from the child domain appear as SEIP (Supervisor External Interrupt-Pending).

In addition to signaling a pending interrupt,
a hart-local APLIC domain signals the priority and identity of the highest priority pending-enabled interrupt to the hart.
This information is accessible at the hart through the {xtopei} CSRs, and influences the arbitration between major and minor interrupts that is ultimately reflected in the {xtopi} CSRs.

=== Interrupt domain control interface (Smidctrl, Ssidctrl)

Smidctrl depends on the Smcsrind and Smaia extensions.
Ssidctrl depends on the Sscsrind and Ssaia extensions.

NOTE: Many AIA features like programmable IPRIO may not be needed in resource-constrained systems. 
Since these are already controlled by WARL registers, implementations can save area by choosing to not support them. +
 +
A minimal implementation of the AIA `mvip` CSR is suggested by the AIA specification: +
"When supervisor mode is implemented, the minimal required implementation of mvien and mvip has all bits being
read-only zeros except for mvip bits 1 and 9, and sometimes bit 5, each of which is an alias of an existing 
writable bit in mip. When supervisor mode is not implemented, registers mvien and mvip do not exist."

The interrupt control interface contains the hart-level interface to operate a hart-local APLIC,
by building on the hart-level features of AIA.

Indirect CSR access to APLIC domains is provided to subsume
the memory-mapped register interface in a hart-local configuration.

This approach has several advantages:

- Built-in privilege level protection: CSRs are clearly mapped to a privilege level.
  Therefore, no additional protection e.g. through PMP is required.
  Especially in systems without memory translation,
  this is beneficial for saving valuable memory protection resources
- Atomic access: Atomic read/write, read & set and read & clear instructions are available for CSRs
- Resource efficiency: Due to smaller access granularity and range,
  implementations using indirect CSRs can be more resource efficient.
- Platform-independent: Memory-mapped base addresses are platform-defined. 
  This places an additional configuration burden in the hands of a user.
  CSR-based interfaces always use the same CSR register numbers

This is achieved by reusing the allocated indirect CSR space for the interrupt pending and enable bits in an IMSIC.
Additional indirect CSR access is provided to the remaining state.

==== Interrupt control interface based on IMSIC interface

ACLIC provides access to interrupt pending and enable bits of the hart-local APLIC domains using the same mechanisms as access to interrupt pending and enable bits in the interrupt files of an IMSIC.

The AIA {eidelivery} and {eithreshold} CSRs defined for the Incoming Message Signaled Interrupt Controller (IMSIC) are not included in the scope of Smidctrl/Ssidctrl.

NOTE: It is not anticipated that ACLIC implementations would allow dynamically switching eidelivery into other modes.
If e.g. MSI delivery is required in a system, it is recommended to use the full AIA implementation with IMSIC.
Therefore, no dynamic selection of ACLIC operation via eidelivery is provided.

In an ACLIC, registers {eipk} and {eiek} serve the same functionality as with {eidelivery} = 1 in an IMSIC,
i.e. they are the pending and enable bits for an interrupt source `k`.
The `eip` and `eie` arrays act as an alias of the pending and enable bits of the connected APLIC domain.

[NOTE]
====
Providing access to APLIC pending and enable bits at the hart-level has several advantages over using an IMSIC with interrupt delivery from an APLIC

  * It removes unnecessary resource duplication between IMSIC and APLIC when integrated with a single hart.
  * It simplifies the handling of level-sensitive interrupts, avoiding additional checking of the pending flag in the APLIC in a handler of a level sensitive interrupt.
  * It simplifies the register interface, as CSR instructions have single bit operations
====

The {xtopei} registers work analogous to the IMSIC operation,
but map to the current highest-priority pending-and-enabled interrupt of the connected APLIC domain.
The {xtopei} CSR reflects both the interrupt identity and the interrupt priority.

[%autowidth,float="center",align="center",cols=">,<",grid=none,frame=none]
|===
|bits 26:16| Interrupt identity
|bits 10:0 | Interrupt priority (configured target[identity].iprio)
|===

==== Indirect CSR access to hart-local APLIC domain configuration

To have full control over the necessary APLIC registers, the following indirect CSR access is added.
The registers xireg4 through xireg6 are reserved and raise an illegal instruction exception
when xiselect is in the range 0x1000-0x1100.

===== Interrupt Priority (iprio)

When XLEN = 32, each `xireg` register controls the ACLIC priority setting of four interrupts.

[%autowidth]
|===
| `xiselect` |  `xireg` size |  `xireg` state
| 0x1000     |   4B          | `acliciprio0`
| ...        |   ...         | ...
| 0x1100     |   4B          | `acliciprio255`
|===

Indirect access to `acliciprio[k]` mirror `target[k*4].iprio` up to `target[k*4+3].iprio`.

When XLEN = 64, only the even-numbered registers exist and each register controls the priority setting of eight interrupts.
Indirect access to `acliciprio[k]` mirror `target[k*4].iprio` up to `target[k*4+7].iprio`.

When XLEN = 64 and xiselect is an odd value in the range 0x1000-0x1100,
attempting to access xireg raises an illegal instruction exception.

===== Source Configuration (sourcecfg)

When accessing the source configuration via indirect CSR, only the lower 16b are accessible,
as the rest of the register is reserved.

When XLEN = 32, the `xireg2` and `xireg3` registers combined control the source configuration of four interrupts.

[%autowidth]
|===
| `xiselect` |  `xireg2/3` size |  `xireg2` state      |  `xireg3` state
| 0x1000     |   4B             | `aclicsourcecfg0`    | `aclicsourcecfg1`
| ...        |   ...            | ...                  | ...
| 0x1100     |   4B             | `aclicsourcecfg510`  | `aclicsourcecfg511`
|===

Indirect access to `aclicsourcecfg[k]` mirrors `sourcecfg[k*2][15:0]` up to `sourcecfg[k*2+1][15:0]`.

When XLEN = 64, only the even-numbered registers exist and the `xireg2` and `xireg3` registers combined control the source configuration of eight interrupts.
Indirect access to `aclicsourcecfg[k]` mirrors `sourcecfg[k*4][15:0]` up to `sourcecfg[k*4+3][15:0]`.

===== State Enable

Additional control is provided for the newly added registers `acliciprio[k]` and `aclicsourcecfg[k]`.

If the Smstateen extension is implemented,
then the bit ?? in mstateen0 is implemented.
If bit ?? of a controlling mstateen0 CSR is zero,
then access to the new CSRs (`acliciprio[k]`, `aclicsourcecfg[k]`) by S-mode or a lower privilege mode
results in an illegal instruction exception,
except if the hypervisor extension is implemented,
and the conditions for a virtual instruction exception apply,
in which case a virtual instruction exception is raised
when in VS or VU mode instead of an illegal instruction exception.

[[smcsps, Smcsps]]
== Conditional Stack Pointer Swap extension (Smcsps, Sscsps)

The Sscsps depends on the Smcsps extension and adds the ability for conditional stack pointer swap at supervisor level and below.

For security and stack safety reasons, it can be desired to separate the stack areas per privilege level and between traps and normal execution.
Performing stack pointer swapping in SW can be time consuming, as the conditions for swapping have to be checked first.
However, stack pointer swapping is among the first things that need to happen even before saving the interrupted context.
To ensure fast interrupt handling, this extension introduces an instruction to accelerate conditional stack pointer swapping.

=== New stack pointer for conditional swap ({xsp}) CSR

New CSRs are introduced to hold an alternative stack pointer.
Conditionally, this stack pointer can be swapped with the currently active one.

[source]
----
      Number  Name         Description
(NEW) 0x349   msp          M-mode stack pointer for conditional swap (WARL)
(NEW) 0x149   ssp          S-mode stack pointer for conditional swap (WARL)
----

The CSR is defined as follows:

[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback"}])
(def row-height 35 )
(def row-header-fn nil)
(def left-margin 100)
(def right-margin 100)
(def boxes-per-row 32)
(draw-column-headers {:height 20 :font-size 18 :labels (reverse ["" "" "0" "" "" "" "" "1" "" "" "2" "" "3" "4" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "XLEN-1" ""])})

(draw-box "SP[XLEN-1:4]" {:span 9 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 10 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "WPRI" {:span 3 :text-anchor "middle" :borders {:top :border-unrelated :bottom :border-unrelated :center :border-unrelated}})
(draw-box "PUSH" {:span 2 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 3 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "PPUSH" {:span 2 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 3 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})

(draw-box "XLEN-4" {:span 19 :borders {}})
(draw-box "2" {:span 3 :borders {}})
(draw-box "1" {:span 5 :borders {}})
(draw-box "1" {:span 5 :borders {}})
----

In addition to the stack pointer, this register holds two additional fields, `PUSH` and `PPUSH` (as in previous `PUSH`).
These indicate if a stack pointer swap is expected during a push or pop sequence, respectively.


NOTE: As per the RISC-V calling convention, stack pointers are 128b aligned.
Therefore the four least significant bits of the stack pointer are zero.

=== Instructions for conditional stack pointer swap

To simplify and accelerate the conditional stack pointer swap, two instructions per mode are introduced:
<<#insns-mcspspush>>, <<#insns-mcspspop>>, <<#insns-scspspush>>, and <<#insns-scspspop>>.
To decide if a stack pointer swap is required, these instructions evaluate the two LSBs of the register.
The `PUSH` bit indicates that the stack pointer in {xsp} shall be swapped during the push sequence of the next handler.

The `PPUSH` bit indicates that the stack pointer shall be swapped back into {xsp}.
It corresponds to the value of the `PUSH` bit in the previous context.
This bit is part of the context of an interrupt handler, and needs to be saved and restored if a handler can be preempted.

Software can deactivate the stack pointer swap mechanism
by writing zero to {xsp}.`PUSH`.

An example sequence with one vertical and one horizontal trap will look like this:

[source]
----
Mode  Event            msp.PUSH  msp.PPUSH  sp-swap
S     -                1         X          n
M     trap             1         X          n
M     mcspspush        0         1          y
M     save context     0         1          n
M     trap             0         1          n
M     mcspspush        0         0          n
M     mcspspop         0         0          n
M     mret             0         0          n
M     restore context  0         1          n
M     mcspspop         1         0          y
S     mret             1         0          n
----

In this example,
the stack pointer is swapped when executing the mcspspush instruction
after taking the trap from from S-mode into M-mode,
and is swapped back through mcspspop before returning to S-mode.
No change of stack pointer occurs for the mcspspush and mcspspop instructions in the nested handler.

=== State Enable

If the Smstateen extension is implemented,
then the bit 53 (ACLIC) in mstateen0 is implemented.
If bit 53 (ACLIC) of a controlling mstateen0 CSR is zero,
then access to the new CSR {ssp} by S-mode or a lower privilege mode
results in an illegal instruction exception,
except if the hypervisor extension is implemented,
and the conditions for a virtual instruction exception apply,
in which case a virtual instruction exception is raised
when in VS or VU mode instead of an illegal instruction exception.

<<<

=== Instructions

[#insns-mcspspush,reftext="Conditional stack pointer swap (push mode) at Machine level"]
==== mcspspush

Synopsis::
Conditional stack pointer swap (push mode)

Mnemonic::
mcspspush rd, rs

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd = x2'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs = x2'], type: 4},
  {bits: 5, name: 0x9, attr: [''], type: 8},
  {bits: 7, name: 0x18, attr: [''], type: 8},
]}
....

Description::

This instruction conditionally swaps out the stack pointer and is typically used while pushing existing context.
The behavior of the operations is:

[source]
----
msp.PPUSH = msp.PUSH         /* Latch push bit into the previous push bit */
if (msp.PUSH == 1)           /* stack pointer shall be swapped */
    tmp = rs                 /* save current sp for writing later */
    rd = msp.SP              /* Write the stack pointer with the low bits cleared */
    msp.SP = tmp[XLEN-1:4]   /* save original value of sp into msp */
    msp.PUSH = 0             /* Indicates the stack pointer has been swapped */
----

Attempting to execute in a mode less privileged than machine level
will raise an illegal-instruction exception.

Included in: <<smcsps>>

<<<

[#insns-mcspspop,reftext="Conditional stack pointer swap (pop mode) at Machine level"]
==== mcspspop

Synopsis::
Conditional stack pointer swap (pop mode)

Mnemonic::
mcspspop

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd = x2'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs = x2'], type: 4},
  {bits: 5, name: 0xC, attr: [''], type: 8},
  {bits: 7, name: 0x18, attr: [''], type: 8},
]}
....

Description::

This instruction performs the opposite operation of mcspspush, and is used to pop the previous context.
A swap is performed, if the `PPUSH` field is set.

Behavior::

[source]
----
msp.PUSH = msp.PPUSH         /* Restore PUSH bit from PPUSH */
if (msp.PPUSH == 1)
    tmp = msp.SP             /* save msp.SP as temporary value */
    msp.SP = rs[XLEN-1:4]    /* write current stack pointer to msp */
    msp.PPUSH = 0            /* Clear previous push bit */
    rd = tmp                 /* write original msp value to stack pointer */
----

Attempting to execute in a mode less privileged than machine level
will raise an illegal-instruction exception.

Included in: <<smcsps>>

<<<

[#insns-scspspush,reftext="Conditional stack pointer swap (push mode) at Supervisor level"]
==== scspspush

Synopsis::
Conditional stack pointer swap (push mode)

Mnemonic::
scspspush rd, rs

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd = x2'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs = x2'], type: 4},
  {bits: 5, name: 0x9, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::

This instruction conditionally swaps out the stack pointer and is typically used while pushing existing context.
The behavior of the operations is:

[source]
----
ssp.PPUSH = ssp.PUSH         /* Latch push bit into the previous push bit */
if (ssp.PUSH == 1)           /* stack pointer shall be swapped */
    tmp = rs                 /* save current sp for writing later */
    rd = ssp.SP              /* Write the stack pointer with the low bits cleared */
    ssp.SP = tmp[XLEN-1:4]   /* save original value of sp into ssp */
    ssp.PUSH = 0             /* Indicates the stack pointer has been swapped */
----

Attempting to execute in a mode less privileged than supervisor level
will raise an illegal-instruction exception.

Included in: <<smcsps,Sscsps>>

<<<

[#insns-scspspop,reftext="Conditional stack pointer swap (pop mode) at Supervisor level"]
==== scspspop

Synopsis::
Conditional stack pointer swap (pop mode)

Mnemonic::
scspspop

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd = x2'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs = x2'], type: 4},
  {bits: 5, name: 0xC, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::

This instruction performs the opposite operation of scspspush, and is used to pop the previous context.
A swap is performed, if the `PPUSH` field is set.

Behavior::

[source]
----
ssp.PUSH = ssp.PPUSH         /* Restore PUSH bit from PPUSH */
if (ssp.PPUSH == 1)
    tmp = ssp.SP             /* save ssp.SP as temporary value */
    ssp.SP = rs[XLEN-1:4]    /* write current stack pointer to ssp */
    ssp.PPUSH = 0            /* Clear previous push bit */
    rd = tmp                 /* write original ssp value to stack pointer */
----

Attempting to execute in a mode less privileged than supervisor level
will raise an illegal-instruction exception.

Included in: <<smcsps,Sscsps>>

<<<

== Horizontal Nested Interrupt Preemption Support (Smnip & Ssnip)

The Smnip extension depends on the Smaia extension and adds nested preemption support at machine level.

The Ssnip extension depends on the Smnip extension and adds nested preemption support at supervisor level.

The extensions enable higher priority interrupts to preempt a lower priority interrupts in a nested fashion.
It provides additional state to resume execution of the previous handler after a nested preemption.

=== Changed and new CSRs at Machine Level

[source]
----
       Number  Name         Description
 (NEW) 0x346   mpistatus    Previous interrupt context
 (NEW) 0x347   mithreshold  Interrupt enable threshold
 (NEW) 0x348   mipreemptcfg Interrupt preemption configuration
----

==== New Interrupt Preemption Configuration ({mipreemptcfg}) CSR

[source]
----
mipreemptcfg fields
 bits        description
 XLEN-1:4    (reserved)
 3:0         preemptmsk
----

{mipreemptcfg} is a WARL register used to configure the behavior of preemption.
The highest legal value of {mipreemptcfg}.{preemptmsk} is IPRIOLEN.

A mask for filtering out the bits of a priority number that will participate in the selection for nested interrupt preemption is:

[source,subs="attributes"]
----
NIPPRIO_MASK = ~(2^(mipreemptcfg.preemptmsk) - 1)
----

==== New Interrupt enable threshold ({mithreshold}) CSR

A new WLRL M-mode CSR, {mithreshold},
determines the minimum interrupt priority (maximum priority number)
for an interrupt to be considered enabled at the hart.

Register {mithreshold} implements exactly IPRIOLEN bits.

[NOTE]
====
In contrast to existing threshold mechanisms in AIA,
this CSR applies to major and minor interrupt identities.

It is needed in an efficient implementation of synchronization protocols like
Priority Ceiling Protocol (PCP) that are used with preemptive interrupt schemes.
====

==== New Previous Interrupt Status ({mpistatus}) CSR

A new M-mode CSR, {mpistatus}, holds consolidated state of preempted context.

[source]
----
mpistatus 
 Bits       Field            Description
 XLEN-1:30  (reserved)
 29:28      mpp[1:0]         Previous privilege mode, mirror of mstatus.mpp
 27         mpie             Previous interrupt enable, mirror of mstatus.mpie
 26:20      (reserved)
 19:18      VS[1:0]          Vector extension status, mirror of mstatus.VS
 17:16      FS[1:0]          Floating-point extension status, mirror of mstatus.FS
 16:9       (reserved)
 8          psppush          Previous stack pointer push, mirror of msp.ppush, if Smcsps is implemented
 7:0        pithreshold[7:0] Previous interrupt enable threshold
----

=== Changed and new CSRs at Supervisor Level

[source]
----
       Number  Name         Description
 (NEW) 0x146   spistatus    Previous interrupt context
 (NEW) 0x147   sithreshold  Interrupt enable threshold
----

==== New Previous Interrupt Status ({spistatus}) CSR

[source]
----
spistatus
 Bits       Field            Description
 XLEN-1:29  (reserved)
 28         spp              Previous privilege mode, mirror of sstatus.spp
 27         spie             Previous interrupt enable, mirror of sstatus.spie
 26:20      (reserved)
 19:18      VS[1:0]          Vector extension status, mirror of mstatus.VS
 17:16      FS[1:0]          Floating-point extension status, mirror of mstatus.FS
 16:9       (reserved)
 8          psppush          Previous stack pointer push, mirror of ssp.ppush, if Sscsps is implemented
 7:0        pithreshold[7:0] Previous interrupt enable threshold
----

The supervisor {sstatus} register has only a single `spp` bit (to
indicate user/supervisor).

==== New Interrupt enable threshold ({sithreshold}) CSR

A new WLRL S-mode CSR, {sithreshold},
determines the minimum interrupt priority (maximum priority number)
for an interrupt to be considered enabled at the hart.

Register {sithreshold} implements exactly IPRIOLEN bits.

=== Reset Behavior

In general, in RISC-V, mandatory reset state is minimized but platform
specifications or company policy might add additional reset
requirements.  Since the general privileged architecture states that
mstatus.mie is reset to zero, interrupts will not be enabled coming
out of reset.

NOTE: For an S-mode execution environment, the EEI should specify
that {sstatus}.`sie` is also reset on entry. It is then responsibility of
the execution environment to ensure that is true before beginning execution
in S-mode.

==== Mandatory reset state

{mithreshold} resets to zero.

The reset behavior of other fields is platform-specific.

=== Operation

When {xithreshold} is a nonzero value,
an interrupt source is considered disabled
irrespective of its interrupt-enable bit,
when the following condition holds:

[source]
----
IPRIO >= xithreshold & NIPPRIO_MASK
----

where `IPRIO` is the value reported in the {xtopi} CSR,
if the interrupt source is the highest priority pending-enabled one.

[NOTE]
====
IPRIO is derived from the configured priority or default priority order
according to the rules defined in AIA.
====

When {xithreshold} is zero,
all enabled interrupt sources can contribute to signaling interrupts to the hart.

==== Trap behavior

The existing trap behavior is modified as follows:

When a trap is taken on interrupt _i_ into level `x`,
the current value of {xithreshold} is written to {xpistatus}.{pithreshold}.
Additionally, {xithreshold} is set to `iprio[i]`.
This automatically raises the interrupt enable threshold.

NOTE: Synchronous exceptions do not modify the value of {xithreshold}.

==== Returns from Handlers

The behavior of an {xret} instruction is modified as follows:

{xret} sets {xithreshold} to {xpistatus}.{pithreshold}.

This automatically restores the interrupt enable threshold to the level of the previous context.


=== State Enable

If the Smstateen extension is implemented,
then the bit 53 (ACLIC) in mstateen0 is implemented.
If bit 53 (ACLIC) of a controlling mstateen0 CSR is zero,
then access to the new CSRs {spistatus} and {sithreshold} by S-mode or a lower privilege mode
results in an illegal instruction exception,
except if the hypervisor extension is implemented,
and the conditions for a virtual instruction exception apply,
in which case a virtual instruction exception is raised
when in VS or VU mode instead of an illegal instruction exception.

== Support for interrupt vector table (Smivt, Ssivt)

These extensions add a new mode for taking interrupts via a dedicated interrupt vector table.

This increases the range of reachable addresses to the entire address space.
This is useful when handlers are more than 2 MiB away from the vector table entry.

In this new mode, when an interrupt is taken, the hart hardware loads the vector
table entry for the associated interrupt (table pointed to the new {xivt} or {xeivt} CSR),
masks off the least-significant bit (for IALIGN=16) or masks off the two least-significant bits (for IALIGN=32),
and then jumps to the masked address.

=== Changed and new CSRs

[source]
----
       Number  Name         Description
       0x305   mtvec        M-mode Trap-handler base address / interrupt mode
 (NEW) 0x307   mivt         M-mode Interrupt-handler vector table base address
 (NEW) 0x308   meivt        M-mode External Interrupt-handler vector table base address
       0x105   stvec        S-mode Trap-handler base address / interrupt mode
 (NEW) 0x107   sivt         S-mode Interrupt-handler vector table base address
 (NEW) 0x108   seivt        S-mode External Interrupt-handler vector table base address
----

==== New {xivt} and {xeivt} CSR

Two new base addresses for vector tables are introduced.
One for internal interrupts (major and local interrupts),
and one for external interrupts.

Both {xivt} and {xeivt} are WARL XLEN-bit CSRs,
which hold the base address of the interrupt vector table.
The address held in {xeivt} is aligned on a 64-byte or greater power-of-two boundary.

{xivt} is defined as follows:

[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback"}])
(def row-height 35 )
(def row-header-fn nil)
(def left-margin 100)
(def right-margin 100)
(def boxes-per-row 32)
(draw-column-headers {:height 20 :font-size 18 :labels (reverse ["0" "" "" "" "" "1" "2" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "XLEN-1" ""])})

(draw-box "BASE" {:span 13 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 13 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "reserved" {:span 3 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WPRI)" {:font-weight "bold"}) {:span 3 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})

(draw-box "XLEN-6" {:span 26 :borders {}})
(draw-box "2" {:span 6 :borders {}})
----

{xeivt} is defined as follows:

[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback"}])
(def row-height 35 )
(def row-header-fn nil)
(def left-margin 100)
(def right-margin 100)
(def boxes-per-row 32)
(draw-column-headers {:height 20 :font-size 18 :labels (reverse ["0" "" "" "" "" "" "" "5" "6" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "XLEN-1" ""])})

(draw-box "BASE" {:span 12 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 12 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "reserved" {:span 4 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WPRI)" {:font-weight "bold"}) {:span 4 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})

(draw-box "XLEN-6" {:span 24 :borders {}})
(draw-box "6" {:span 8 :borders {}})
----


NOTE: The actual alignment can be determined
by writing ones to the low-order bits
then reading them back.

NOTE: The resulting vector tables, especially for external interrupts,
can consume non-negligible memory space.
To limit the overall memory footprint,
{xivt} or {xeivt} values at different privilege levels may be configured to the same values, respectively.

==== New {xtvec} CSR Mode

Interrupt vector table mode is encoded as a new state in the
existing {xtvec} WARL register, where {xtvec}.`mode` (the two
least-significant bits) is `11`.

==== Smivt Changes to {xtvec} CSR Mode

The PC upon interrupt is changed as follows:

[source]
----
 mode  PC on Interrupt
 00    OBASE                                # Direct mode
 01    OBASE+4*exccode                      # Vectored mode
 11    M[VTBASE+XLEN/8*vtoffset] & VTMASK   # Interrupt vector table mode
 10    Reserved

where:
  M[a]     = Contents of memory address at address "a"
  VTMASK   = ~0x1 if IALIGN=16 or ~0x3 if IALIGN=32
  exccode  = xcause.Exception Code

  OBASE  = xtvec[XLEN-1:2]<<2   # Vector base is at least 4-byte aligned
  if external interrupt:
    VTBASE = xeivt[XLEN-1:6]<<6   # External Interrupt Vector Table base is at least 64-byte aligned
    vtoffset = Minor Interrupt Identity
    # Corresponds to xtopei[26:16] with interrupt delivery from interrupt file or ACLIC
  else
    VTBASE = xivt[XLEN-1:2]<<2    # Interrupt Vector Table base is at least 4-byte aligned
    vtoffset = Major Interrupt Identity
----

In interrupt vector table mode, when interrupts are taken, the interrupt behavior is modified as follows:
After executing the required side-effects as required with the existing behavior,
the hart then fetches an XLEN-bit handler address with permissions corresponding to the handler's mode
from the in-memory table whose base address (VTBASE).
The trap handler function address is fetched from `VTBASE+XLEN/8*exccode`.
If the fetch is successful, the hart clears the low bit(s) (depending on IALIGN) of the handler address,
and sets the PC to this handler address.
The masked vector table entry bit(s) are reserved and should be zero.

NOTE: The original vectored mode simply jumps to an address in
the trap vector table, while the interrupt vector table mode reads a
handler function address from the table, and jumps to it in hardware.

For permissions-checking purposes, the memory access to retrieve the
function pointer for hardware vectoring is an _implicit_ fetch at the
privilege mode of the interrupt handler, and requires execute
permission; read permission is irrelevant.
It is recommended that the vector table fetches are ignored for hardware triggers and breakpoints.

Memory writes to the vector table require an instruction barrier (_fence.i_) to guarantee that they are visible to the instruction fetch.

It is recommended that the second fetch be ignored for hardware triggers and breakpoints.

==== Vector table fault handling

Faults that occur during the fetch of interrupt vector table entries are only recoverable,
if the double trap extension(s) are implemented.
For interrupts in M-mode, this additionally requires the Smrnmi extension.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

In this case, if an exception trap occurs during the interrupt handler function address fetch,
the following holds true:
Depending on where the second trap is handled,
the corresponding exception pc ({xepc} or {mnepc}) value is set to the exception pc of the first trap.
In addition, {tval} is either set to zero or written with the faulting address.

NOTE: For simpler systems, we do not require that {tval} is written
with the faulting address.  For systems with demand paging, {tval}
should be written with the faulting address to simplify page-fault
handling code.

NOTE: After returning from handling the synchronous exception, another trap will happen immediately.
In case a higher priority interrupt became pending and enabled, this will trap first.

As long as synchronous exceptions can occur during the interrupt vector table fetch,
side-effects of the trap may only be executed if they allow resuming of operation after the handling of the synchronous exception.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

==== State Enable

If the Smstateen extension is implemented,
then the bit 53 (ACLIC) in mstateen0 is implemented.
If bit 53 (ACLIC) of a controlling mstateen0 CSR is zero,
then access to the new CSR {sivt} by S-mode or a lower privilege mode
results in an illegal instruction exception,
except if the hypervisor extension is implemented,
and the conditions for a virtual instruction exception apply,
in which case a virtual instruction exception is raised
when in VS or VU mode instead of an illegal instruction exception.

== Synchronous exception hardware vectoring (Smehv, Ssehv)

The Smehv extension depends upon the Smivt extension.

Accelerating synchronous exception handlers through vectoring may reduce interrupt latency.
During synchronous exceptions, interrupts are disabled.
Acceleration of this critical segment decreases the time during which interrupts are masked.
Typical examples of synchronous exceptions that occur as part of normal program execution include traps due to ECALLs, misaligned accesses, instruction page faults, or illegal instructions.

With this extension, synchronous exceptions can be vectored using xtvec as an offset.

=== Changed CSRs

[source]
----
       Number  Name         Description
       0x307   mivt         M-mode Interrupt-handler vector table base address
       0x107   sivt         S-mode Interrupt-handler vector table base address
----

==== Changes to the {xivt} CSR

The CSR is changed by adding a bit to control
if synchronous exception hardware vectoring is active.

[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback"}])
(def row-height 35 )
(def row-header-fn nil)
(def left-margin 100)
(def right-margin 100)
(def boxes-per-row 32)
(draw-column-headers {:height 20 :font-size 18 :labels (reverse ["" "" "0" "" "" "" "" "1" "" "" "2" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "XLEN-1" ""])})

(draw-box "BASE" {:span 11 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 11 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "reserved" {:span 3 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WPRI)" {:font-weight "bold"}) {:span 2 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})
(draw-box "EHV" {:span 2 :text-anchor "end" :borders {:top :border-unrelated :bottom :border-unrelated :left :border-unrelated}})
(draw-box (text "(WARL)" {:font-weight "bold"}) {:span 3 :text-anchor "start" :borders {:top :border-unrelated :bottom :border-unrelated :right :border-unrelated}})

(draw-box "XLEN-2" {:span 22 :borders {}})
(draw-box "1" {:span 5 :borders {}})
(draw-box "1" {:span 5 :borders {}})
----

=== Operation

When {xivt}.{EHV} is clear, the exception trap behavior is unchanged.

When {xivt}.{EHV} is set, the synchronous exceptions trap to the following entry point:

[source]
----
 mode  PC on Synchronous Exception
 00       OBASE              # Direct mode
 01       OBASE              # Vectored mode
 11       OBASE+4*exccode    # Interrupt vector table mode
 10       Reserved
----

[[smip, Smip]]
== Interrupt handler push and pop extension (Smip & Ssip)

The interrupt handler push and pop extension adds automatic (partial) context save and restore behavior.
Interrupt handler latency is reduced by allowing the context save to happen in parallel with the handler fetch,
which may include the fetch of the vector table entry.

NOTE: In Harvard architectures, the data bus may be idle while the vector table and handler fetch are happening.
By starting the context save in parallel, the available data bus bandwidth can be utilized, reducing interrupt latency.

NOTE: In some implementations, executing the context save in parallel to the fetches of the vector table entry and the first instruction
may contribute to reducing the jitter in interrupt latency,
by masking variable delays e.g. caused by cache misses on handler fetch.

Additional latency reduction can be achieved by implementing late-preemption of the push sequence in favor of a higher-priority interrupt or synchronous exception.
Interrupt handling throughput is increased by allowing tail-chaining of interrupts or synchronous exceptions, skipping the context restore and save in between servicing two handlers.

This extension does not affect Non-Maskable Interrupts (NMIs).

=== Controlling the extension behavior

This extension adds additional control bits to enable/disable the extended behavior.

If `MIPU`, is set, a trap taken at Machine level due to an interrupt causes automatic stacking.
If `SIPU`, is set, a trap taken at Supervisor level due to an interrupt causes automatic stacking.

If one of the bits is clear, the trap behavior at the respective level is unmodified.

NOTE: These bits do not yet have an allocated encoding.
The authors of this specification intend to ask for encoding of these bits in mstatus/sstatus.

NOTE: The state of these bits does not influence the behavior of mipopret/sipopret.

=== Interrupt trap behavior

The existing trap behavior is modified.
Before executing the first instruction of the trap handler,
this extension ensures the interrupted context is partially saved.

It performs the following operations in order:

  * Save registers x10-x15 (these are the caller saved registers available in RVC)
  * Adjusts the stack pointer to create the stack frame
  * Conditionally performs a stack pointer swap by executing cspspush sp

NOTE: Intentionally, the GPRs are saved on the stack owned by the interrupted context.
This is done to simplify and accelerate OS thread switching.

NOTE: As this extension modifies interrupt trap behavior but not the behaviour of synchronous exception traps,
it should only be used in interrupt handling modes that provide separate entry points for
interrupt and synchronous exception traps.
Specifically, mtvec.mode = 0 (direct) is incompatible.

NOTE: This extension does not require a normative stack layout.
Interrupt handlers do not require access to the interrupted context.

=== Returns from interrupt handlers

When executing an {xipopret} instruction the context saved during the trap is restored and a return is executed.

NOTE: An explicit interrupt return instruction is included, rather than modifying the xret behavior,
so that the hart does not need to do bookkeeping whether it is in an interrupt or exception context.

It performs the following actions in order:

  * Conditionally performs a stack pointer swap by executing xcspspop sp
  * Restores registers x10-x15
  * Adjust the stack pointer to destroy the stack frame
  * Executes an xret according to the current level

NOTE: As this instruction is intended to be executed at the end of the handler, interrupts are typically disabled during its execution.
It is however an implementation choice to perform tail-chaining to the next highest priority pending-enabled interrupt upon this instruction.

=== C interrupt handlers

When this extension is implemented, a compiler may assume for any interrupt handler defined with the interrupt attribute like

[source,c]
----
void interrupt_handler() __attribute__((interrupt));
----

that the registers x10-x15 have been saved.
Additionally, the compiler does not need to restore these registers.
Finally, it should generate an {xipopret} instruction at the end of the function instead of an {xret}.

=== Late Preemption of the interrupt handler

While executing the trap side effects of an interrupt, it is allowed for an implementation to optionally check for higher priority pending and enabled interrupts at the current privilege mode, and switch to fetching this interrupt handler instead.

=== Tail chaining of interrupt handlers

While executing the xipopret instruction,
it is allowed for an implementation to of a hart
to optionally check for any pending and enabled interrupts at the current privilege mode.

If such an interrupt exists, the hart may abort executing the xipopret instruction and trigger the following actions:
  - Update the `xcause.Exception Code` to the corresponding interrupt id.
  - Perform the interrupt handler fetch.
  - Start executing the interrupt handler, while skipping the portions of context restore that have not yet been executed by the aborted xipopret.

Explicitly, {xepc}, {xpistatus} remain unchanged.

NOTE: In the typical case of tail chaining, the check for another pending enabled interrupt is at the start of the xipopret instruction.
In this case, the entire context save and restore sequence can be skipped.

=== Fault handling

If synchronous exceptions can occur during the context save/restore segments,
handling can only be resumed if the double trap extension is supported.

<<<

=== Instructions

==== mipopret

Synopsis::
Pop interrupt context and return

Mnemonic::
mipopret

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 4},
  {bits: 5, name: 0x8, attr: [''], type: 8},
  {bits: 7, name: 0x18, attr: [''], type: 8},
]}
....

Description::
Restores an interrupted context at the end of an interrupt and returns to the previous context

Behavior::

Can be executed at machine level.
Attempting to execute in a mode less privileged than machine level
will raise an illegal-instruction exception.
The behavior in RISC-V assembly is as follows:

[source]
----
mipopret:
  mcspspop sp, sp           # Swap stack pointer with msp
  lr a0, OFFSET(sp)         # Restore a0
  lr a1, OFFSET(sp)         # Restore a1
  lr a2, OFFSET(sp)         # Restore a2
  lr a3, OFFSET(sp)         # Restore a3
  lr a4, OFFSET(sp)         # Restore a4
  lr a5, OFFSET(sp)         # Restore a5
  lr a6, OFFSET(sp)         # Restore a6
  addi sp, sp, FRAMESIZE    # Adjust stack pointer
  mret

where
  lr is lw on RV32 and ld on RV64
----

The order and access size of the loads, as well as the OFFSETS, are implementation-defined.

Included in: <<smip>>

<<<

==== sipopret

Synopsis::
Pop interrupt context and return

Mnemonic::
sipopret

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 4},
  {bits: 5, name: 0x8, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::
Restores an interrupted context at the end of an interrupt and returns to the previous context

Behavior::

Can be executed at machine or supervisor level.
Attempting to execute in a mode less privileged than supervisor level
will raise an illegal-instruction exception.
The behavior in RISC-V assembly is as follows:

[source]
----
sipopret:
  scspspop sp, sp           # Swap stack pointer with ssp
  lr a0, OFFSET(sp)         # Restore a0
  lr a1, OFFSET(sp)         # Restore a1
  lr a2, OFFSET(sp)         # Restore a2
  lr a3, OFFSET(sp)         # Restore a3
  lr a4, OFFSET(sp)         # Restore a4
  lr a5, OFFSET(sp)         # Restore a5
  lr a6, OFFSET(sp)         # Restore a6
  addi sp, sp, FRAMESIZE    # Adjust stack pointer
  sret

where
  lr is lw on RV32 and ld on RV64
----

The order and access size of the loads, as well as the OFFSETS, are implementation-defined.

Included in: <<smip,Ssip>>
