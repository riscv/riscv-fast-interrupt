:sectnums:
:toc: left

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;


[[riscv-doc-template]]
= Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions
include::../docs-resources/global-config.adoc[]
:docgroup: RISC-V Task Group
:description: RISC-V Example Specification Document (Zexmpl)
:revdate: current
:revnumber: dev
:revremark: This document is under development. Expect potential changes. Visit http://riscv.org/spec-state for further details.
:revinfo:
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
// https://docs.asciidoctor.org/asciidoc/latest/macros/images-directory/
:imagesdir: ../docs-resources/images
:title-logo-image: image:risc-v_logo.png["RISC-V International Logo",pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
//:srcdir: src
:bibtex-file: src/example.bib
:bibtex-order: alphabetical
:bibtex-style: apa
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short


Graphics used are either explicitly available for free, are property of RISC-V International, or were created using Wavedrom.

:status: pass:q[``**__x__**status``]
:ideleg: pass:q[``**__x__**ideleg``]
:ie: pass:q[``**__x__**ie``]
:tvec: pass:q[``**__x__**tvec``]
:ivt: pass:q[``**__x__**ivt``]
:scratch: pass:q[``**__x__**scratch``]
:scratchcsw: pass:q[``**__x__**scratchcsw``]
:scratchcswl: pass:q[``**__x__**scratchcswl``]
:epc: pass:q[``**__x__**epc``]
:cause: pass:q[``**__x__**cause``]
:tval: pass:q[``**__x__**tval``]
:ip: pass:q[``**__x__**ip``]
:pintstatus: pass:q[``**__x__**pintstatus``]
:intstatus: pass:q[``**__x__**intstatus``]
:intthresh: pass:q[``**__x__**intthresh``]

// Make M-mode and S-mode of monospace formatting substitutions for smclic and ssclic chapter references to CSRs.
:mstatus: pass:q[``mstatus``]
:mideleg: pass:q[``mideleg``]
:mie: pass:q[``mie``]
:mtvec: pass:q[``mtvec``]
:mivt: pass:q[``mivt``]
:mscratch: pass:q[``mscratch``]
:msp: pass:q[``msp``]
:mepc: pass:q[``mepc``]
:mnepc: pass:q[``mnepc``]
:mcause: pass:q[``mcause``]
:mtval: pass:q[``mtval``]
:mip: pass:q[``mip``]
:mpintstatus: pass:q[``mpintstatus``]
:mintstatus: pass:q[``mintstatus``]
:mipreemptcfg: pass:q[``mipreemptcfg``]
:preemptmsk: pass:q[``preemptmsk``]
:mintthresh: pass:q[``mintthresh``]
:mtopi: pass:q[``mtopi``]
:mclaimi: pass:q[``mclaimi``]
:mithreshold: pass:q[``mithreshold``]

:sstatus: pass:q[``sstatus``]
:sideleg: pass:q[``sideleg``]
:sie: pass:q[``sie``]
:stvec: pass:q[``stvec``]
:sivt: pass:q[``sivt``]
:sscratch: pass:q[``sscratch``]
:ssp: pass:q[``ssp``]
:sepc: pass:q[``sepc``]
:scause: pass:q[``scause``]
:stval: pass:q[``stval``]
:sip: pass:q[``sip``]
:spintstatus: pass:q[``spintstatus``]
:sintthresh: pass:q[``sintthresh``]
:stopi: pass:q[``stopi``]
:sclaimi: pass:q[``sclaimi``]
:sithreshold: pass:q[``sithreshold``]

:pp: pass:q[``**__x__**pp``]
:pie: pass:q[``**__x__**pie``]
:nipprio: pass:q[``**__x__**nipprio``]

:mpp: pass:q[``mpp``]
:mpie: pass:q[``mpie``]
:mnipprio: pass:q[``mnipprio``]

:pnipprio: pass:q[``**__x__**pnipprio``]

:mpippro: pass:q[``mpippro``]

:ret: pass:q[``**__x__**ret``]
:mret: pass:q[``mret``]

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;

// SPDX-License-Identifier: CC-BY-4.0
//
// licensing.adoc: licensing information
//
// Copyright and licensing information for the specification.
//

[Preface]
== Copyright and license information

This RISC-V CLIC extension specification is © 2018-2025 RISC-V international

This document is released under a Creative Commons Attribution 4.0
International License. +
https://creativecommons.org/licenses/by/4.0/.

Please cite as: “Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions",  RISC-V International

This document is a derivative of the "The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document
version 1.9.1" released under following license: © 2010–2017 Andrew Waterman,
Yunsup Lee, Rimas Aviˇzienis, David Patterson, Krste Asanovi ́c.
Creative Commons Attribution 4.0 International License.

== CLIC extensions
This section gives an overview for the Core-Local Interrupt
Controller (CLIC) extensions.

This table provides a summary of the CLIC extensions.

[%autowidth]
|===
| Extension Name | Description
| smclicincr   | Increase of the number of local interrupts for M-mode
| ssclicincr   | Increase of the number of local interrupts for S-mode
| smclic       | Horizontal Nested Interrupt Preemption support for M-mode
| ssclic       | Horizontal Nested Interrupt Preemption support for S-mode
| Smclicivt     | Hardware Vectored Interrupts
| Smclicsehv   | Synchronous exceptions hardware vectoring
| sditrig      | support for interrupt debug triggering
| Smtp         | Support for trap handler push/pop
| Smcspsw      | Conditional stack pointer swap at machine level
| Sscspsw      | Conditional stack pointer swap at supervisor level
|===

NOTE: The extensions defined here are orthogonal to the NMI and RNMI
machanisms. Their behavior is unchanged by the extensions of CLIC.

== Increase of AIA local interrupts - smclicincr

The Smclicincr extension depends on the Smcsrind and Smaia extensions.

The smclicincr extension increases support up to 4096 interrupt inputs per hart.
Each interrupt input _i_ has five control
registers: an interrupt-pending bit (`clicintip[__i__]`),
an interrupt-enable bit (`clicintie[__i__]`), interrupt attributes
(`clicintattr[__i__]`) to specify trigger type, 
(`cliciprio[__i__]`) to specify priority, and 
(`clicmideleg[__i__]`) to delegate interrupts to a lower privilege level.

=== CLIC Interrupt Priority (`cliciprio`)
Each interrupt has an associated priority as defined in the AIA specification.
For the first 64 interrupts, these registers mirror the values of iprio registers in the AIA specification and follow the default 
priorities as specified in the AIA standard major interrupt codes, listed in default priority order table.
For interrupts after the first 64 interrupts, smaller priority numbers convey higher priority. 
For interrupts after the first 64 interrupts, when interrupt sources have equal `cliciprio` priority number, the source with the lowest identity number has the highest priority.
When interrupt sources have equal `cliciprio` priority number, the first 64 interrupts have higher priority than interrupts after the first 64 interrupts.

NOTE: Implementations that do not require software compliance with AIA defined major interrupt numbers 
may choose to only implement interrupts 64 and above to simplify default priority calculations.

=== CLIC Interrupt Delegation (`clicmideleg`)
Each interrupt has an associated interrupt privilege mode delegation as defined in the AIA specification.
For the first 64 interrupts, these registers mirror the values of mideleg bits in the AIA specification.

=== CLIC Interrupt Attribute (`clicintattr`)

This is an 8-bit WARL read-write register to specify various attributes for each interrupt.

NOTE: This register is defined as WARL as some implementations may want to hardwire to fixed values
only trigger types.

.clicintattr[i] register layout
include::images/wavedrom/clicintattri.edn[]

The 2-bit `trig` WARL field specifies the trigger type and polarity for each
interrupt input. Bit 1, `trig[0]`, is defined as "edge-triggered"
(0: level-triggered, 1: edge-triggered); while bit 2, `trig[1]`, is defined
as "negative-edge" (0: positive-edge, 1: negative-edge).
More specifically, there can be four possible combinations:
positive level-triggered, negative level-triggered, positive edge-triggered,
and negative edge-triggered.

=== CLIC Interrupt Pending (`clicintip`)
Each interrupt has an associated interrupt pending.
For the first 64 interrupts, these registers mirror the values of mip CSR.

When the input is configured for level-sensitive input, the
`clicintip[__i__]` bit reflects the value of an input signal to the
interrupt controller after any conditional inversion specified by the
`clicintattr[__i__]` field, and software writes to the bit are ignored.
Software clears the interrupt at the source device.

When the input is configured for edge-sensitive input,
`clicintip[__i__]` is a read-write register that can be updated both
by hardware interrupt inputs and by software.  The bit is set by
hardware after an edge of the appropriate polarity is observed on the
interrupt input, as determined by the `clicintattr[__i__]` field.
Software writes to `clicintip[__i__]` can set or
clear edge-triggered pending bits directly by writes to the
`clicintip[__i__]` register. 
`clicintip[__i__]` behavior is unaffected by `clicintie[__i__]` setting.


The value in the `clicintip[__i__]` is undefined when switching from
level-sensitive mode to edge-triggered mode in `clicintattr[__i__]`.

NOTE: Software cannot rely on the underlying `clicintip[__i__]`
register bits used in edge-triggered mode to hold state while in
level-sensitive mode.

=== CLIC Interrupt Enable (`clicintie`)
Each interrupt has an associated interrupt enable.
For the first 64 interrupts, these bits mirror the values of mie CSR.

Each interrupt input has a dedicated interrupt-enable WARL bit (`clicintie[__i__]`)
This control bit is read-write to enable/disable the corresponding interrupt.
Software should assume `clicintie[__i__]`=0 means no interrupt enabled, and `clicintie[__i__]`=1 indicates an interrupt is enabled.

NOTE: `clicintie[__i__]` is the individual enable bit while {status}.{ie} is
the global enable bit for the current privilege mode. Therefore, for an
interrupt `_i_` to be enabled in the current privilege mode, both `clicintie[__i__]`
and {status}.{ie} have to be set.


NOTE: In contrast, since {status}.{ie} only takes effect in the current privilege
mode according to RISC-V convention, an interrupt `_i_` from a higher privilege mode
is enabled as long as `clicintie[__i__]` is set (regardless of the setting
of {status}.{ie} in the higher privilege modes).

NOTE: This register bit is defined as WARL as unimplemented interrupts appear hardwired to zero.

=== Indirect Access M-mode CLIC interrupt CSRs

Access to CLIC registers `clicintattr[__i__]`, `clicintip[__i__]`, `clicintie[__i__]`, `cliciprio[__i__]`, and `clicideleg[__i__]`
utilizes the Indirect CSR Access extension (Smcsrind/Sscsrind). Implementations may support
another method to access these CSRs (e.g., via memory-mapped accesses) and any such a definition is outside the scope
of the CLIC specification.

If an interrupt _i_ is not present in the hardware, the corresponding CLIC register
locations appear hardwired to zero.

All CLIC registers are visible to M-mode.

NOTE: Since accessing clic registers via indirect CSR access is not atomic, 
indirect CSR access of these registers while same privilege mode {mstatus}.`mie` is enabled 
requires `mireg` register state to be part of the interrupt handler's overall context state save/restore, 
although this is expected to be an atypical need for most interrupt handlers.

==== `clicintattr[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg2` register controls the clic attribute setting of four interrupts, with one 8-bit byte per interrupt.

[%autowidth]
|===
| `miselect` |  `mireg2` bits |  `mireg2` state              | description

| 0x1000+i   |   7:0          | RW  `clicintattr[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `clicintattr[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `clicintattr[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `clicintattr[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic attribute setting of eight interrupts.

[%autowidth]
|===
| `miselect` |  `mireg2` bits |  `mireg2` state              | description

| 0x1000+i   |   7:0          | RW  `clicintattr[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `clicintattr[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `clicintattr[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `clicintattr[__i__*4+3]` |  setting for interrupt __i__*4+3
| 0x1000+i   |  39:32         | RW  `clicintattr[__i__*4+4]` |  setting for interrupt __i__*4+4
| 0x1000+i   |  47:40         | RW  `clicintattr[__i__*4+5]` |  setting for interrupt __i__*4+5
| 0x1000+i   |  55:48         | RW  `clicintattr[__i__*4+6]` |  setting for interrupt __i__*4+6
| 0x1000+i   |  63:56         | RW  `clicintattr[__i__*4+7]` |  setting for interrupt __i__*4+7
|===


==== `cliciprio[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg3` register controls the clic priority setting of four interrupts

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state              | description
| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic priority setting of eight interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state              | description
| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
| 0x1000+i   |  39:32         | RW  `cliciprio[__i__*4+4]` |  setting for interrupt __i__*4+4
| 0x1000+i   |  47:40         | RW  `cliciprio[__i__*4+5]` |  setting for interrupt __i__*4+5
| 0x1000+i   |  55:48         | RW  `cliciprio[__i__*4+6]` |  setting for interrupt __i__*4+6
| 0x1000+i   |  63:56         | RW  `cliciprio[__i__*4+7]` |  setting for interrupt __i__*4+7
|===

==== `clicintip[__i__]` and `clicintie[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg` register reflects the interrupt pending of thirty-two interrupts and
each `mireg2` register controls the interrupt enable of thirty-two interrupts.

[%autowidth]
|===
| `miselect` |  `mireg` bits |  `mireg` state            |  `mireg2` bits |  `mireg2` state           | description
| 0x1400     |   31:0        | RW `clicintip[31:0]`      |   31:0         | RW `clicintie[31:0]`      | settings for interrupts 31 through 0
| 0x1401     |   31:0        | RW `clicintip[63:32]`     |   31:0         | RW `clicintie[63:32]`     | settings for interrupts 63 through 32
6*^| ...
| 0x147F     |   31:0        | RW `clicintip[4095:4064]` |   31:0         | RW `clicintie[4095:4064]` | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `mireg` register reflects the interrupt pending of sixty-four interrupts and
each `mireg2` register controls the interrupt enable of sixty-four interrupts.

[%autowidth]
|===
| `miselect` |  `mireg` bits |  `mireg` state            |  `mireg2` bits |  `mireg2` state           | description
| 0x1400     |   63:0        | RW `clicintip[63:0]`      |   63:0         | RW `clicintie[63:0]`      | settings for interrupts 63 through 0
| 0x1402     |   63:0        | RW `clicintip[127:64]`    |   63:0         | RW `clicintie[127:64]`    | settings for interrupts 127 through 64
6*^| ...
|===

==== `clicideleg[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg3` register controls the interrupt delegation of thirty-two interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state            | description
| 0x1400     |   31:0        | RW `clicideleg[31:0]`      | settings for interrupts 31 through 0
| 0x1401     |   31:0        | RW `clicideleg[63:32]`     | settings for interrupts 63 through 32
4*^| ...
| 0x147F     |   31:0        | RW `clicideleg[4095:4064]` | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `mireg3` register controls the interrupt delegation of sixty-four interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state            | description
| 0x1400     |   63:0        | RW `clicideleg[63:0]`       | settings for interrupts 63 through 0
| 0x1402     |   127:64      | RW `clicideleg[127:64]`     | settings for interrupts 127 through 64
4*^| ...
|===

=== New CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x???   mclaimi      Claim top interrupt
 (NEW) 0x???   mithreshold  Interrupt enable threshold
----

==== Claim top interrupt (mclaimi)

Register {mclaimi} has the same value as {mtopi}.
When this value is not zero,
reading {mclaimi} has the simultaneous side effect of clearing the pending bit for the reported interrupt identity,
if possible.
Writes to {mclaimi} are ignored.

==== Interrupt enable threshold (mithreshold)

{mithreshold} is a WLRL register that determines the minimum interrupt priority (maximum priority
number) for an interrupt to be to be considered enabled.
Register {mithreshold} implements exactly IPRIOLEN bits,
and thus is capable of holding all priority numbers from 0 to latexmath:[${{2}^{\textrm{IPRIOLEN}} - {1}}$].
When {mithreshold} is a nonzero value P,
interrupt sources with priority numbers P and higher behave as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits.

== Increase of AIA local interrupts - ssclicincr

The Ssclicincr extension depends on the Sscsrind and Ssaia extensions.

=== Indirect Access S-mode CSRs

If an interrupt _i_ is not present in the hardware, the corresponding CLIC register
locations appear hardwired to zero.

In S-mode, if an interrupt _i_ is not accessible to S-mode, the corresponding CLIC register
locations appear hardwired to zero.

==== `clicintattr[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg` register controls the clic priority setting of four interrupts
and each `sireg2` register controls the clic attribute setting of four interrupts

[%autowidth]
|===
| `siselect`   |  `sireg2` bits |  `sireg2` state          | description

| 0x1000+_i_   |   7:0        | RW  `clicintattr[_i_*4+0]` |  setting for interrupt _i_*4+0
| 0x1000+_i_   |  15:8        | RW  `clicintattr[_i_*4+1]` |  setting for interrupt _i_*4+1
| 0x1000+_i_   |  23:16       | RW  `clicintattr[_i_*4+2]` |  setting for interrupt _i_*4+2
| 0x1000+_i_   |  31:24       | RW  `clicintattr[_i_*4+3]` |  setting for interrupt _i_*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic attribute setting of eight interrupts.

==== `cliciprio[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg3` register controls the clic priority setting of four interrupts

[%autowidth]
|===
| `siselect` |  `sireg3` bits |  `sireg3` state              | description

| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic priority setting of eight interrupts.

==== `clicintip[__i__]` and `clicintie[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg` register reflects the interrupt pending of thirty-two interrupts.
and each `sireg2` register controls the interrupt enable of thirty-two interrupts.

[%autowidth]
|===
| `siselect`   |  `sireg` bits |  `sireg` state          |  `sireg2` bits |  `sireg2` state          | description

| 0x1400    |   31:0   | RW `clicintip[31:0]`      |   31:0    | RW `clicintie[31:0]`       | settings for interrupts 31 through 0
| 0x1401    |   31:0   | RW `clicintip[63:32]`     |   31:0    | RW `clicintie[63:32]`      | settings for interrupts 63 through 32
6*^| ...
| 0x147F    |   31:0   | RW `clicintip[4095:4064]` |   31:0    | RW `clicintie[4095:4064]`  | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `sireg` register reflects the interrupt pending of sixty-four interrupts and
each `sireg2` register controls the interrupt enable of sixty-four interrupts.

=== New CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x???   sclaimi      Claim top interrupt
----

==== Claim top interrupt (sclaimi)

Register {sclaimi} has the same value as {stopi}.
When this value is not zero,
reading {sclaimi} has the simultaneous side effect of clearing the pending bit for the reported interrupt identity,
if possible.
Writes to {sclaimi} are ignored.

==== Interrupt enable threshold (smithreshold)

{sithreshold} is a WLRL register that determines the minimum interrupt priority (maximum priority
number) for an interrupt to be to be considered enabled.
Register {smithreshold} implements exactly IPRIOLEN bits,
and thus is capable of holding all priority numbers from 0 to latexmath:[${{2}^{\textrm{IPRIOLEN}} - {1}}$].
When {sithreshold} is a nonzero value P,
interrupt sources with priority numbers P and higher behave as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits.

== Horizontal Nested Interrupt Preemption support for M-mode - smclic

The Smclic extension depends on the Smaia extension.

The Smclic extension enables higher priority interrupts to preempt a lower priority interrupts in a nested fashion.
It provides additional state to resume execution of the previous handler after a nested preemption.

=== Changed and new CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x346   mpintstatus  Previous interrupt context
 (NEW) 0xFB1   mintstatus   Current interrupt context
 (NEW) 0x347   mipreemptcfg Interrupt preemption configuration
----

==== New Interrupt Preemption Configuration ({mipreemptcfg}) CSR

[source]
----
mipreemptcfg fields
 bits        description
 XLEN-1:4    (reserved)
 3:0         preemptmsk

----

{mipreemptcfg} is a WARL register used to configure the behavior of preemption.
{mipreemptcfg}.{preemptmsk} configures the number of least significant bits of iprio masked out for constructing {nipprio}.
The highest legal value of {mipreemptcfg}.{preemptmsk} is IPRIOLEN.
The nested interrupt preemption priority {nipprio} is defined as follows:

[source]
----
NIPPRIO_MASK = ~(2^(mipreemptcfg.preemptmsk) - 1)
nipprio[i]   = iprio[i] & NIPPRIO_MASK
----

A nested horizontal preemption will happen if and only if an interrupt i is pending and enabled,
and the preemption priority of that interrupt nipprio[i] exceeds (i.e. is numerically smaller) than {mintstatus}.{mnipprio}.

Depending on the number of implemented priority bits, the maximum value of {nipprio} is

[source]
----
IPRIO_MAX  = 2^(IPRIOLEN)
NIPPRIO_MAX = IPRIO_MAX & NIPPRIO_MASK
----

In order to differentiate between regular and interrupt execution,
interrupts shall not be configured in a way, that {nipprio} equals NIPPRIO_MAX.

==== New Interrupt Status ({mpintstatus}) CSR

A new M-mode CSR, `mpintstatus`, holds consolidated state of preempted context.

[source]
----
mpintstatus 
Bits   Field           Description
 XLEN-1 Interrupt      Set to 1 for interrupts and 0 for exceptions.  Mirror of mcause.Interrupt
 30     (reserved)
 29:28  mpp[1:0]       Previous privilege mode, mirror of mstatus.mpp
 27     mpie           Previous interrupt enable, mirror of mstatus.mpie
 26:24  (reserved)
 23:16  mpnipprio[7:0] Previous nested interrupt preemption priority
 15:0   (reserved)
----

==== New Interrupt Status ({mintstatus}) CSR

A new M-mode CSR, `mintstatus`, holds the active nested interrupt preemption priority for
each supported privilege mode.  These fields are read-only.  The
primary reason to expose these fields is to support debug.

[source]
----
mintstatus fields
 bits    description
 31:24   mnipprio
 23:16   (reserved)
 15: 8   snipprio if ssclic is supported
  7: 0   (reserved)
----

=== Reset Behavior

In general in RISC-V, mandatory reset state is minimized but platform
specifications or company policy might add additional reset
requirements.  Since the general privileged architecture states that
mstatus.mie is reset to zero, interrupts will not be enabled coming
out of reset.

==== Mandatory reset state

{mintstatus}.{mnipprio} and {mpintstatus}.{mpnipprio} fields reset to the highest possible value NIPPRIO_MAX.

The reset behavior of other fields is platform-specific.

=== Interrupt Operation

This section describes the operation of smclic interrupts.

==== Trap behavior

The existing trap behavior for interrupts is modified as follows:

When a trap _i_ is taken,
the current value of {mintstatus}.{mnipprio} is written to {mpintstatus}.{mpnipprio}.
If the trap is taken on an interrupt, {mintstatus}.{mnipprio} is updated to `iprio[__i__]`.

NOTE: Synchronous exceptions do not modify the value of {mintstatus}.{mnipprio}.

==== Returns from Handlers

The behavior of an {mret} instruction is modified as follows:

{mret} sets {mintstatus}.{mnipprio} to {mpintstatus}.{mpnipprio}.

== Horizontal Nested Interrupt Preemption support for S-mode - ssclic

The Ssclic extension depends on the Smclic and Ssaia extensions.
When S-mode and the Smclic extensions are implemnted, Ssclic is mandatory.

=== Changed and new CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x146   spintstatus  Previous interrupt context
----

==== New Interrupt Status ({spintstatus}) CSR

[source]
----
spintstatus
 Bits    Field         Description
 XLEN-1 Interrupt      Interrupt=1, Exception=0, same as scause.Interrupt
 30:29  (reserved)
    28  spp            Previous privilege mode, same as sstatus.spp
    27  spie           Previous interrupt enable, same as sstatus.spie
 26:24  (reserved)
 23:16  spnipprio[7:0] Previous nested interrupt preemption priority
 15:0   (reserved)
----

The supervisor {scause} register has only a single `spp` bit (to
indicate user/supervisor) mirrored from {sstatus}.`spp`.

=== Reset Behavior

Nested interrupt preemption priority NIPPRIO_MAX corresponds to regular
execution outside of an interrupt handler.

NOTE: For an S-mode execution environment, the EEI should specify
that {sstatus}.`sie` is also reset on entry. It is then responsibility of
the execution environment to ensure that is true before beginning execution
in S-mode.

=== Interrupt Operation

This section describes the operation of ssclic interrupts.
The behavior is modified in analogy to smclic.

==== Trap behavior

When a trap _i_ is taken,
the current value of {sintstatus}.{snipprio} is written to {spintstatus}.{spnipprio}.
If the trap is taken on an interrupt, {sintstatus}.{snipprio} is updated to `iprio[__i__]`.

NOTE: Synchronous exceptions do not modify the value of {sintstatus}.{snipprio}.

==== Returns from Handlers

The behavior of an {sret} instruction is modified as follows:

{sret} sets {sintstatus}.{snipprio} to {spintstatus}.{spnipprio}.

==== State Enable

If the Smstateen extension is implemented, then the bit 53 (CLIC) in mstateen0 is
implemented. If bit 53 (CLIC) of a controlling mstateen0 CSR is zero, then
access to the new CSR ({sivt})
by S-mode or a lower privilege mode
results in an illegal instruction exception, except if the hypervisor
extension is implemented and the conditions for a virtual instruction
exception apply, in which case a virtual instruction exception is
raised when in VS or VU mode instead of an illegal instruction
exception.

== Support for far hardware vectored interrupts - Smclicivt

To increase the range of reachable addresses, this extension adds a new vectoring mode.
This is useful when handlers are more than 2 MiB away from the vector table entry.

In this new mode, when an interrupt is taken, the hart hardware loads the vector
table entry for the associated interrupt (table pointed to new {mivt} CSR),
masks off the least-significant bit (for IALIGN=16) or masks of the 2 least-significant bits (for IALIGN=32),
and then jumps to the masked address.

=== Smclicivt Changes to CLIC CSRs

=== Changed and new CSRs

[source]
----
       Number  Name         Description
       0x305   mtvec        Trap-handler base address / interrupt mode
 (NEW) 0x307   mivt         Interrupt-handler vector table base address
----

==== New {mivt} CSR

The {mivt} WARL XLEN-bit CSR holds the base address of the interrupt vector
table, aligned on a 64-byte or greater power-of-two boundary.
Values other than 0 in the low 6 bits of {mivt} are reserved.

NOTE: The actual alignment can be determined
by writing ones to the low-order bits
then reading them back.

==== New {mtvec} CSR Mode for CLIC

Far hardware vectored interrupt-handling mode is encoded as a new state in the
existing {mtvec} WARL register, where {mtvec}.`mode` (the two
least-significant bits) is `11`.

.xtvec register layout
include::images/wavedrom/xtvec.edn[]

==== Smclicivt Changes to {tvec} CSR Mode for CLIC

The PC upon interrupt is changed as follows:

[source]
----
 mode  PC on Interrupt
 00    OBASE                                # Direct mode
 01    OBASE+4*exccode                      # Vectored mode
 11    M[VTBASE+XLEN/8*exccode] & VTMASK    # Interrupt vector table mode
 10    Reserved

where:
  OBASE  = xtvec[XLEN-1:2]<<2   # Vector base is at least 4-byte aligned
  VTBASE = xivt[XLEN-1:6]<<6    # Interrupt Vector Table base is at least 64-byte aligned
  M[a]   = Contents of memory address at address "a"
  VTMASK = ~0x1 if IALIGN=16 or ~0x3 if IALIGN=32
----

In interrupt vector table mode, when interrupts are taken, the interrupt behavior is modified as follows:
After executing the required side-effects as required with the existing behavior,
the hart then fetches an XLEN-bit handler address with permissions corresponding to the handler's mode
from the in-memory table whose base address (VTBASE) is in {ivt}.
The trap handler function address is fetched from `VTBASE+XLEN/8*exccode`.
If the fetch is successful, the hart clears the low bit(s) (depending on IALIGN) of the handler address,
and sets the PC to this handler address.
The masked vector table entry bit(s) are reserved and should be zero.

The vector table layout will look like this for RV32 and RV64, respectively:

[source]
----
           # Vector table layout for RV32 (4-byte function pointers)
  mivt ->  0x800000 # Interrupt 0 handler function pointer
           0x800004 # Interrupt 1 handler function pointer
           0x800008 # Interrupt 2 handler function pointer
           0x80000c # Interrupt 3 handler function pointer

           # Vector table layout for RV64 (8-byte function pointers)
  mivt ->  0x800000 # Interrupt 0 handler function pointer
           0x800008 # Interrupt 1 handler function pointer
           0x800010 # Interrupt 2 handler function pointer
           0x800018 # Interrupt 3 handler function pointer
----

NOTE: The original vectored mode simply jumps to an address in
the trap vector table, while the interrupt vector table mode reads a
handler function address from the table, and jumps to it in hardware.

For permissions-checking purposes, the memory access to retrieve the
function pointer for hardware vectoring is an _implicit_ fetch at the
privilege mode of the interrupt handler, and requires execute
permission; read permission is irrelevant.
It is recommended that the vector table fetches are ignored for hardware triggers and breakpoints.

Memory writes to the vector table require an instruction barrier (_fence.i_) to guarantee that they are visible to the instruction fetch.

It is recommended that the second fetch be ignored for hardware triggers and breakpoints.

==== Vector table fault handling

Faults that occur during the fetch of interrupt vector table entries are only recoverable,
if the double trap extension(s) are implemented.
For interrupts in M-mode, this additionally requires the Smrnmi extension.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

In this case, if an exception trap occurs during the interrupt handler function address fetch,
the following holds true:
Depending on where the second trap is handled,
the corresponding exception pc ({mepc} or {mnepc}) value is set to the exception pc of the first trap.
In addition, {tval} is either set to zero or written with the faulting address.

NOTE: For simpler systems, we do not require that {tval} is written
with the faulting address.  For systems with demand paging, {tval}
should be written with the faulting address to simplify page-fault
handling code.

NOTE: After returning from handling the synchronous exception, another trap will happen immediately.
In case a higher priority interrupt became pending and enabled, this will trap first.

As long as synchronous exceptions can occur during the interrupt vector table fetch,
side-affects of the trap may only be executed if they allow resuming of operation after the handling of the synchronous exception.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

== Synchronous exceptions hardware vectoring- Smclicsehv

The Smclicsehv extension depends upon the Smclicivt extension.

Accelerating synchronous exception handlers through vectoring may reduce interrupt latency.
During synchronous exceptions, interrupts are disabled.
Acceleration of this critical segment decreases the time during which interrupts are masked.
Typical examples of synchronous exceptions that occur as part of normal program execution include traps due to ecalls, misaligned accesses, instruction page faults, or illegal instructions.

With this extension, synchronous exceptions are vectored using xtvec as an offset.
The summarized behavior is the following:

[source]
----
 mode  PC on Synchronous Exception
 00       OBASE              # Direct mode
 01       OBASE              # Vectored mode
 11       OBASE+4*exccode    # Far vectored mode
 10       Reserved
----

== Interrupt trigger Debug extension- sditrig

=== Interrupt Trigger (`dbginttrig`)

Optional interrupt triggers (`dbginttrig[__i__]`) are used to generate
a breakpoint exception, entry into Debug Mode, or a trace action.
If these registers are not implemented, they appear as hard-wired zeros.

NOTE: The notation [__i__] for the dbginttrig register in this section treats __i__ not an interrupt number
but is instead as a trigger number.

This logic is intended to be used with `tmexttrigger`.`intctl`` as described in the RISC-V debug specification.

Each interrupt trigger is a 32-bit WARL register with the
following layout:

.dbginttrig register layout
include::images/wavedrom/dbginttrig.edn[]

The `interrupt_number` field selects which number of interrupt input
is used as the source for this interrupt trigger.

The `interrupt_trap_enable` control bit is read-write to enable/disable this
interrupt trigger.  A trigger is signaled to the debug module if an interrupt trap is taken and the interrupt code matches a `dbginttrig[__i__]`.interrupt_number and the associated `dbginttrig[__i__]`.interrupt_trap_enable is set.

=== sditrig machine level CSRs

==== `dbginttrig[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg` register controls an interrupt trigger register.

[%autowidth]
|===
| `miselect`     |  `mireg` bits |  `mireg` state              |  description

| 0x1480         |     31:0      |   RW   `dbginttrig[0]`     |  interrupt trigger 0
| 0x1480 + __i__ |     31:0      |   RW   `dbginttrig[__i__]` |  interrupt trigger __i__
4*^| ...
| 0x149F         |     31:0      |   RW   `dbginttrig[31]`    |  interrupt trigger 31
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the interrupt trigger setting of two interrupts.

== Smcspsw Conditional Stack Pointer Swap extension

For security and stack safety reasons, it can be desired to separate the stack areas per privilege level and between traps and normal execution.
Performing stack pointer swaping in SW can be time consuming, as the conditions for swapping have to be checked first.
However, stack pointer swapping is among the first things that need to happen even before saving the interrupted context.
To ensure fast interrupt handling, this extension introduces an instruction to accelerate conditional stack pointer swapping.

=== Separate stacks per privilege mode

The stack separation per privilege mode is controlled through the xsp CSR.
If this reads the value zero, no conditional stack swap is performed.
Else, the xcspw instruction can be used to atomically swap the stack pointer with the xsp register if a mode change happened.

[source]
----
      Number  Name         Description
(NEW) 0x348   msp          Stack pointer for conditional swap (WARL)
----

This mechanism can also be used to initialize the sp value of a less privileged mode.
If an operating system manages separate stacks per software thread in a lower privileged mode, this mechanism can also be applied.

=== Separate stacks for interrupts

The same instruction can be used to separate the stack of non-interrupt execution from interrupts at the same privilege level.
This is beneficial to ensure the integrity of the interrupts stack independently of the non-interrupt stack.
The interrupt stack pointer at a given privilege level has to be initialized by writing to the xtsp CSR.
If using xcspsw to swap stack pointers before changing to a lower privilege level, the current value of sp will be used as stack pointer in trap handling at the current privilege level. 
After a trap, the xcspw instruction will swap the previous sp with the value in xsp if {insert CSR here}.xtspsw is asserted.

=== xcspsw

The xcspsw instruction conditional swaps the sp register with the xsp register.

Encoding tbd. Assume this includes the PRIV field.

Behavior:

[source]
----

# Stack pointer swap condition (SPSC) in a trap handler:
exception_spsc = true if exception was taken from (xnipprio == NIPPRIO_MAX)
interrupt_spsc = (xnipprio == NIPPRIO_MAX) != (xpnipprio == NIPPRIO_MAX)
trap_spsc = exception_spsc or interrupt_spsc

if ((xsp != 0) and (trap_spsc or (PRIV != xpp)))
{
  tmp = sp
  sp = xsp
  xsp = tmp
}
----

== Sscspsw Conditional Stack Pointer Swap extension

The Sscspsw depends on the Smcspsw extension.

It adds a new supervisor level CSR ssp.

[source]
----
      Number  Name         Description
(NEW) 0x148   ssp          Stack pointer for conditional swap (WARL)
----

If ssp reads a non-zero value, the xcspsw conditionally perfoms a stack pointer swap with ssp.
The behavior is analogous to Smcspsw.

=== State Enable

If the Smstateen extension is implemented, then the bit 53 (CLIC) in mstateen0 is
implemented. If bit 53 (CLIC) of a controlling mstateen0 CSR is zero, then
access to the new CSRs ({ssp})
by S-mode or a lower privilege mode
results in an illegal instruction exception, except if the hypervisor
extension is implemented and the conditions for a virtual instruction
exception apply, in which case a virtual instruction exception is
raised when in VS or VU mode instead of an illegal instruction
exception.

== Smtp Trap handler push and pop extension

The trap handler push and pop extension adds instructions to accelerate trap handling, which additionally reduce code size.
Trap handler latency and jitter is reduced by allowing the context save to happen speculatively in parallel to the vector table and handler fetch.
Additional latency reduction is achieved by allowing late-preemption of the push sequence in favor of a higher priority interrupt or synchronous exception.
Trap handling throughput is increased by allowing tail-chaing of interrupts or synchronous exceptions, skipping the context restore and save in between servicing two handlers.
The instructions are designed to be applicable to all RISC-V trap handling schemes.

=== Trap handler push and pop functional overview

1. The tpush instruction
* Conditionally performs a stack pointer swap by executing xcspsw
* Saves hart's state of the preempted context that can be overwritten in case of a nested preemption
* Save registers x10-x15 (these are the caller saved registers available in RVC)
* Adjusts the stack pointer to create the stack frame
* Clear the ip bit if writable
* Write trap information to argument registers
* Optionally, enable interrupts and clear the xstatus.XDT flag if the double trap extension is implemented at the current privilege level

NOTE: If a trap occurs during the sequence, then any operations which were executed before the trap may update architectural state and/or memory contents.
The preempting trap is expected to fully save and restore the architectural state that it overwrites.
If the trap occurs before updating the stack pointer, it needs to be assumed that the stacked context was overwritten.
In this case, if the instruction is resumed, any store operations must be re-executed.

The tpush instruction writes the value of the xcause CSR into register a0.
This is beneficial also with vectored interrupts, as it allows sharing the same handler for similar interrupt sources.
For example, if a peripheral exists multiple times in a system at different offsets, this can be handled with one handler.

The following table summarizes the written trap information:

[%autowidth]
|===
| Register | synchronous exception | interrupt
| a0       | xcause | xcause
| a1       | xtval | no write
| a2       | xtval2 | no write
| a3       | xtinst | no write
|===

Software shall only use the information from the argument registers, as the corresponding CSRs may be overwritten by preempting traps.
The values of xtval, xtval2, and xinst only need to be written to an argument register if the corresponding exception cause a write to the respective CSR.

2. The tpopxret instruction
* Disables interrupts
* Set the xstatus.XDT flag if the double trap extension is implemented at the current privilege level
* Restores registers x10-x15
* Restores the the hart's state to the point that the hart can return to the interrupted context
* Adjust the stack pointer to destroy the stack frame
* Conditionally performs a stack pointer swap by executing xcspsw
* Executes an xret according to the current level

NOTE: If a trap occurs during the sequence, then any operations which were executed before the trap may update architectural state.
A trap may not occur after updating the stack pointer, if the context was not yet fully restored from the stack.

There is no specific order mandated for the context save/restore, and the individual parts may occur in parallel.
Interrupts shall not be enabled before completing the context save/restore operations of the tpush instruction.
Interrupts must be disabled before starting to restore context in the tpopxret instruction.
As interrupts are disabled during the sequence as a side effect of the trap being taken, intermediate states during the execution of the instruction are not observable.

If the Smtp extension is implemented, the first and last instructions of a trap handler must be a tpush and the last a tpopxret instruction, respectively.

NOTE: In contrast to the Zcmp push/pop intructions, Smtp instructions do not encode an incremental stack pointer adjustment in order to ease late preemption and tail chaining.

With these requirements, implementations are allowed to speculatively start executing an tpush instruction in case of a taken interrupt.

=== Late Preemption of the interrupt handler

While executing the tpush instruction, a hart may optionally check for higher priority pending and enabled interrupts at the current privilege mode, and switch to fetching this trap handler instead.
Once the instruction retires, or the interrupts are disabled, no late preemption can occur.

=== Tail chaining of interrupts handlers

While executing the tpopxret instruction, a hart may optionally check for any pending and enabled interrupts at the current privilege mode.
If such an interrupt exists, the hart may abort executing the tpopxret instruction and trigger the following actions:
  - Update the xcause.exccode to the corresponding interrupt id.
  - Perform the trap handler fetch.
  - Start excuting the trap handler, while skipping the portions of tpush that have not been reverted by the aborted tpopxret.

Explicitly, xepc, xpil, and xpp remain unchanged.

NOTE: In the typical case of tail chaining, the check for another pending enabled interrupt is done after disabling interrupts at the start of the tpopxret instruction. In this case, only the conditional interrupt enablement of the tpush instruction would need to executed.

Once the instruction retires, or the interrupts are disabled, no late preemption can occur.

=== Stack layout

To ease debugging, a stack layout is specified for the saved context.

#TODO: find the best way to specify the memory layout in asciidoc

* xtvec.mode != CLIC:
** XXLEN = 32:

stack pointer adjustment: 32

24: x15

20: x14

16: x13

12: x12

8: x11

4: x10

** XXLEN = 64:

stack pointer adjustment: 48

48: x15

40: x14

32: x13

24: x12

16: x11

8: x10

* xtvec.mode = CLIC:

start of stackframe remains same. In addition:

** XXLEN = 32

stack pointer adjustment: 32

32: xpintstatus (XXLEN)

28: xpepc (XXLEN)

** XXLEN = 32

stack pointer adjustment: 64

60: xpintstatus (XXLEN)

56: xpepc (XXLEN)

=== Fault handling

Unless it can be guaranteed by design that faults causing synchronous exceptions cannot occure during the critical section,
handling can only be resumed if the double trap extension is supported.
The critical sections are defined as the time during execution of the tpush and tpopxret instruction, during which interrupts are disabled.

=== Debug

As the execution of tpush may start before the instruction is fetched, breakpoint conditions met might observe an inconsistent state.
Therefore, if a breakpoint is triggered because of an tpush instruction, the breakpoint shall be handled as if it occured on the subsequent instruction.

=== Instructions

#TODO: define encodings, sail etc.

==== tpush

==== tpopxret

== CLIC Parameters

Although these are described as parameters, it is understood that hardware implementations may wish to
have a single implementation support different parameterizations of CLIC extensions and may make
these values configurable and initialized prior to CLIC operation. 
However, these parameters should functionally be considered static. If the value of these parameters are changed
during CLIC operation, CLIC behavior is undefined.

=== CLICINFO Parameters

The NUM_INTERRUPT 13-bit parameter from 2-4096 that specifies the actual number of maximum interrupt
inputs supported in this implementation. MSIP, MTIP are always included.

The VERSION 8-bit parameter specifies the implementation version of CLIC. The upper
4-bit specifies the architecture version, and the lower 4-bit specifies
the implementation version.

The NUM_TRIGGER 6-bit parameter specifies the number of maximum interrupt
triggers supported in this implementation. Valid values are 0 to 32.

=== Additional CLIC Parameters

[source]
----
Name           Value Range  Description
CLICMAXID      12-4095      Largest interrupt ID

INTTHRESHBITS  1-8          Number of bits implemented in {intthresh}.th
CLICMTVECALIGN >= 2         Number of hardwired-zero LSBs in mtvec address.
----
NOTE: These parameters are likely to be available by the general
discovery mechanism that is in development.
