:sectnums:
:toc: left

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;


[[riscv-doc-template]]
= Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions
include::../docs-resources/global-config.adoc[]
:docgroup: RISC-V Task Group
:description: RISC-V Example Specification Document (Zexmpl)
:revdate: current
:revnumber: dev
:revremark: This document is under development. Expect potential changes. Visit http://riscv.org/spec-state for further details.
:revinfo:
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
// https://docs.asciidoctor.org/asciidoc/latest/macros/images-directory/
:imagesdir: ../docs-resources/images
:title-logo-image: image:risc-v_logo.png["RISC-V International Logo",pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
//:srcdir: src
:bibtex-file: src/example.bib
:bibtex-order: alphabetical
:bibtex-style: apa
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short


Graphics used are either explicitly available for free, are property of RISC-V International, or were created using Wavedrom.

:status: pass:q[``**__x__**status``]
:ideleg: pass:q[``**__x__**ideleg``]
:ie: pass:q[``**__x__**ie``]
:tvec: pass:q[``**__x__**tvec``]
:ivt: pass:q[``**__x__**ivt``]
:scratch: pass:q[``**__x__**scratch``]
:scratchcsw: pass:q[``**__x__**scratchcsw``]
:scratchcswl: pass:q[``**__x__**scratchcswl``]
:epc: pass:q[``**__x__**epc``]
:cause: pass:q[``**__x__**cause``]
:tval: pass:q[``**__x__**tval``]
:ip: pass:q[``**__x__**ip``]
:pintstatus: pass:q[``**__x__**pintstatus``]
:intstatus: pass:q[``**__x__**intstatus``]
:intthresh: pass:q[``**__x__**intthresh``]

// Make M-mode and S-mode of monospace formatting substitutions for Smclic and Ssclic chapter references to CSRs.
:mstatus: pass:q[``mstatus``]
:mideleg: pass:q[``mideleg``]
:mie: pass:q[``mie``]
:mtvec: pass:q[``mtvec``]
:mivt: pass:q[``mivt``]
:mscratch: pass:q[``mscratch``]
:msp: pass:q[``msp``]
:mepc: pass:q[``mepc``]
:mnepc: pass:q[``mnepc``]
:mcause: pass:q[``mcause``]
:mtval: pass:q[``mtval``]
:mip: pass:q[``mip``]
:mpintstatus: pass:q[``mpintstatus``]
:mintstatus: pass:q[``mintstatus``]
:mipreemptcfg: pass:q[``mipreemptcfg``]
:preemptmsk: pass:q[``preemptmsk``]
:mintthresh: pass:q[``mintthresh``]
:mtopi: pass:q[``mtopi``]
:mclaimi: pass:q[``mclaimi``]
:mithreshold: pass:q[``mithreshold``]

:sstatus: pass:q[``sstatus``]
:sideleg: pass:q[``sideleg``]
:sie: pass:q[``sie``]
:stvec: pass:q[``stvec``]
:sivt: pass:q[``sivt``]
:sscratch: pass:q[``sscratch``]
:ssp: pass:q[``ssp``]
:sepc: pass:q[``sepc``]
:scause: pass:q[``scause``]
:stval: pass:q[``stval``]
:sip: pass:q[``sip``]
:spintstatus: pass:q[``spintstatus``]
:sintthresh: pass:q[``sintthresh``]
:stopi: pass:q[``stopi``]
:sclaimi: pass:q[``sclaimi``]
:sithreshold: pass:q[``sithreshold``]

:pp: pass:q[``**__x__**pp``]
:pie: pass:q[``**__x__**pie``]
:nipprio: pass:q[``**__x__**nipprio``]

:mpp: pass:q[``mpp``]
:mpie: pass:q[``mpie``]
:mnipprio: pass:q[``mnipprio``]

:pnipprio: pass:q[``**__x__**pnipprio``]

:mpippro: pass:q[``mpippro``]

:ret: pass:q[``**__x__**ret``]
:mret: pass:q[``mret``]

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;

// SPDX-License-Identifier: CC-BY-4.0
//
// licensing.adoc: licensing information
//
// Copyright and licensing information for the specification.
//

[Preface]
== Copyright and license information

This RISC-V CLIC extension specification is © 2018-2025 RISC-V international

This document is released under a Creative Commons Attribution 4.0
International License. +
https://creativecommons.org/licenses/by/4.0/.

Please cite as: “Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions",  RISC-V International

This document is a derivative of the "The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document
version 1.9.1" released under following license: © 2010–2017 Andrew Waterman,
Yunsup Lee, Rimas Aviˇzienis, David Patterson, Krste Asanovi ́c.
Creative Commons Attribution 4.0 International License.

== CLIC extensions
This section gives an overview for the Core-Local Interrupt
Controller (CLIC) extensions.

This table provides a summary of the CLIC extensions.

[%autowidth]
|===
| Extension Name | Description
| Smclicincr   | Increase of the number of local interrupts for M-mode
| Ssclicincr   | Increase of the number of local interrupts for S-mode
| Smclic       | Horizontal Nested Interrupt Preemption support for M-mode
| Ssclic       | Horizontal Nested Interrupt Preemption support for S-mode
| Smclicivt    | Hardware Vectored Interrupts
| Smclicsehv   | Synchronous exceptions hardware vectoring
| Smtp         | Support for trap handler push/pop
| Smcsps       | Conditional stack pointer swap at machine level
| Sscsps       | Conditional stack pointer swap at supervisor level
|===

NOTE: The extensions defined here are orthogonal to the NMI and RNMI
machanisms. Their behavior is unchanged by the extensions of CLIC.

== Increase of AIA local interrupts - Smclicincr

The Smclicincr extension depends on the Smcsrind and Smaia extensions.

The Smclicincr extension increases support up to 4096 interrupt inputs per hart.
Each interrupt input _i_ has five control
registers: an interrupt-pending bit (`clicintip[__i__]`),
an interrupt-enable bit (`clicintie[__i__]`), interrupt attributes
(`clicintattr[__i__]`) to specify trigger type, 
(`cliciprio[__i__]`) to specify priority, and 
(`clicmideleg[__i__]`) to delegate interrupts to a lower privilege level.

=== CLIC Interrupt Priority (`cliciprio`)
Each interrupt has an associated priority as defined in the AIA specification.
For the first 64 interrupts, these registers mirror the values of iprio registers in the AIA specification and follow the default 
priorities as specified in the AIA standard major interrupt codes, listed in default priority order table.
For interrupts after the first 64 interrupts, smaller priority numbers convey higher priority. 
For interrupts after the first 64 interrupts, when interrupt sources have equal `cliciprio` priority number, the source with the lowest identity number has the highest priority.
When interrupt sources have equal `cliciprio` priority number, the first 64 interrupts have higher priority than interrupts after the first 64 interrupts.

NOTE: Implementations that do not require software compliance with AIA defined major interrupt numbers 
may choose to only implement interrupts 64 and above to simplify default priority calculations.

=== CLIC Interrupt Delegation (`clicmideleg`)
Each interrupt has an associated interrupt privilege mode delegation as defined in the AIA specification.
For the first 64 interrupts, these registers mirror the values of mideleg bits in the AIA specification.

=== CLIC Interrupt Attribute (`clicintattr`)

This is an 8-bit WARL read-write register to specify various attributes for each interrupt.

NOTE: This register is defined as WARL as some implementations may want to hardwire to fixed values
only trigger types.

.clicintattr[i] register layout
include::images/wavedrom/clicintattri.edn[]

The 2-bit `trig` WARL field specifies the trigger type and polarity for each
interrupt input. Bit 1, `trig[0]`, is defined as "edge-triggered"
(0: level-triggered, 1: edge-triggered); while bit 2, `trig[1]`, is defined
as "negative-edge" (0: positive-edge, 1: negative-edge).
More specifically, there can be four possible combinations:
positive level-triggered, negative level-triggered, positive edge-triggered,
and negative edge-triggered.

=== CLIC Interrupt Pending (`clicintip`)
Each interrupt has an associated interrupt pending.
For the first 64 interrupts, these registers mirror the values of mip CSR.

When the input is configured for level-sensitive input, the
`clicintip[__i__]` bit reflects the value of an input signal to the
interrupt controller after any conditional inversion specified by the
`clicintattr[__i__]` field, and software writes to the bit are ignored.
Software clears the interrupt at the source device.

When the input is configured for edge-sensitive input,
`clicintip[__i__]` is a read-write register that can be updated both
by hardware interrupt inputs and by software.  The bit is set by
hardware after an edge of the appropriate polarity is observed on the
interrupt input, as determined by the `clicintattr[__i__]` field.
Software writes to `clicintip[__i__]` can set or
clear edge-triggered pending bits directly by writes to the
`clicintip[__i__]` register. 
`clicintip[__i__]` behavior is unaffected by `clicintie[__i__]` setting.


The value in the `clicintip[__i__]` is undefined when switching from
level-sensitive mode to edge-triggered mode in `clicintattr[__i__]`.

NOTE: Software cannot rely on the underlying `clicintip[__i__]`
register bits used in edge-triggered mode to hold state while in
level-sensitive mode.

=== CLIC Interrupt Enable (`clicintie`)
Each interrupt has an associated interrupt enable.
For the first 64 interrupts, these bits mirror the values of mie CSR.

Each interrupt input has a dedicated interrupt-enable WARL bit (`clicintie[__i__]`)
This control bit is read-write to enable/disable the corresponding interrupt.
Software should assume `clicintie[__i__]`=0 means no interrupt enabled, and `clicintie[__i__]`=1 indicates an interrupt is enabled.

NOTE: `clicintie[__i__]` is the individual enable bit while {status}.{ie} is
the global enable bit for the current privilege mode. Therefore, for an
interrupt `_i_` to be enabled in the current privilege mode, both `clicintie[__i__]`
and {status}.{ie} have to be set.


NOTE: In contrast, since {status}.{ie} only takes effect in the current privilege
mode according to RISC-V convention, an interrupt `_i_` from a higher privilege mode
is enabled as long as `clicintie[__i__]` is set (regardless of the setting
of {status}.{ie} in the higher privilege modes).

NOTE: This register bit is defined as WARL as unimplemented interrupts appear hardwired to zero.

=== Indirect Access M-mode CLIC interrupt CSRs

Access to CLIC registers `clicintattr[__i__]`, `clicintip[__i__]`, `clicintie[__i__]`, `cliciprio[__i__]`, and `clicideleg[__i__]`
utilizes the Indirect CSR Access extension (Smcsrind/Sscsrind). Implementations may support
another method to access these CSRs (e.g., via memory-mapped accesses) and any such a definition is outside the scope
of the CLIC specification.

If an interrupt _i_ is not present in the hardware, the corresponding CLIC register
locations appear hardwired to zero.

All CLIC registers are visible to M-mode.

NOTE: Since accessing clic registers via indirect CSR access is not atomic, 
indirect CSR access of these registers while same privilege mode {mstatus}.`mie` is enabled 
requires `mireg` register state to be part of the interrupt handler's overall context state save/restore, 
although this is expected to be an atypical need for most interrupt handlers.

==== `clicintattr[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg2` register controls the clic attribute setting of four interrupts, with one 8-bit byte per interrupt.

[%autowidth]
|===
| `miselect` |  `mireg2` bits |  `mireg2` state              | description

| 0x1000+i   |   7:0          | RW  `clicintattr[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `clicintattr[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `clicintattr[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `clicintattr[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic attribute setting of eight interrupts.

[%autowidth]
|===
| `miselect` |  `mireg2` bits |  `mireg2` state              | description

| 0x1000+i   |   7:0          | RW  `clicintattr[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `clicintattr[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `clicintattr[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `clicintattr[__i__*4+3]` |  setting for interrupt __i__*4+3
| 0x1000+i   |  39:32         | RW  `clicintattr[__i__*4+4]` |  setting for interrupt __i__*4+4
| 0x1000+i   |  47:40         | RW  `clicintattr[__i__*4+5]` |  setting for interrupt __i__*4+5
| 0x1000+i   |  55:48         | RW  `clicintattr[__i__*4+6]` |  setting for interrupt __i__*4+6
| 0x1000+i   |  63:56         | RW  `clicintattr[__i__*4+7]` |  setting for interrupt __i__*4+7
|===


==== `cliciprio[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg3` register controls the clic priority setting of four interrupts

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state              | description
| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic priority setting of eight interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state              | description
| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
| 0x1000+i   |  39:32         | RW  `cliciprio[__i__*4+4]` |  setting for interrupt __i__*4+4
| 0x1000+i   |  47:40         | RW  `cliciprio[__i__*4+5]` |  setting for interrupt __i__*4+5
| 0x1000+i   |  55:48         | RW  `cliciprio[__i__*4+6]` |  setting for interrupt __i__*4+6
| 0x1000+i   |  63:56         | RW  `cliciprio[__i__*4+7]` |  setting for interrupt __i__*4+7
|===

==== `clicintip[__i__]` and `clicintie[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg` register reflects the interrupt pending of thirty-two interrupts and
each `mireg2` register controls the interrupt enable of thirty-two interrupts.

[%autowidth]
|===
| `miselect` |  `mireg` bits |  `mireg` state            |  `mireg2` bits |  `mireg2` state           | description
| 0x1400     |   31:0        | RW `clicintip[31:0]`      |   31:0         | RW `clicintie[31:0]`      | settings for interrupts 31 through 0
| 0x1401     |   31:0        | RW `clicintip[63:32]`     |   31:0         | RW `clicintie[63:32]`     | settings for interrupts 63 through 32
6*^| ...
| 0x147F     |   31:0        | RW `clicintip[4095:4064]` |   31:0         | RW `clicintie[4095:4064]` | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `mireg` register reflects the interrupt pending of sixty-four interrupts and
each `mireg2` register controls the interrupt enable of sixty-four interrupts.

[%autowidth]
|===
| `miselect` |  `mireg` bits |  `mireg` state            |  `mireg2` bits |  `mireg2` state           | description
| 0x1400     |   63:0        | RW `clicintip[63:0]`      |   63:0         | RW `clicintie[63:0]`      | settings for interrupts 63 through 0
| 0x1402     |   63:0        | RW `clicintip[127:64]`    |   63:0         | RW `clicintie[127:64]`    | settings for interrupts 127 through 64
6*^| ...
|===

==== `clicideleg[__i__]`

In this `miselect` offset range:

* When XLEN = 32, each `mireg3` register controls the interrupt delegation of thirty-two interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state            | description
| 0x1400     |   31:0        | RW `clicideleg[31:0]`      | settings for interrupts 31 through 0
| 0x1401     |   31:0        | RW `clicideleg[63:32]`     | settings for interrupts 63 through 32
4*^| ...
| 0x147F     |   31:0        | RW `clicideleg[4095:4064]` | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `mireg3` register controls the interrupt delegation of sixty-four interrupts.

[%autowidth]
|===
| `miselect` |  `mireg3` bits |  `mireg3` state            | description
| 0x1400     |   63:0        | RW `clicideleg[63:0]`       | settings for interrupts 63 through 0
| 0x1402     |   127:64      | RW `clicideleg[127:64]`     | settings for interrupts 127 through 64
4*^| ...
|===

=== New CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x???   mclaimi      Claim top interrupt
 (NEW) 0x???   mithreshold  Interrupt enable threshold
----

==== Claim top interrupt (mclaimi)

Register {mclaimi} has the same value as {mtopi}.
When this value is not zero,
reading {mclaimi} has the simultaneous side effect of clearing the pending bit for the reported interrupt identity,
if possible.
Writes to {mclaimi} are ignored.

==== Interrupt enable threshold (mithreshold)

{mithreshold} is a WLRL register that determines the minimum interrupt priority (maximum priority
number) for an interrupt to be to be considered enabled.
Register {mithreshold} implements exactly IPRIOLEN bits,
and thus is capable of holding all priority numbers from 0 to latexmath:[${{2}^{\textrm{IPRIOLEN}} - {1}}$].
When {mithreshold} is a nonzero value P,
interrupt sources with priority numbers P and higher behave as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits.

== Increase of AIA local interrupts - Ssclicincr

The Ssclicincr extension depends on the Sscsrind and Ssaia extensions.

=== Indirect Access S-mode CSRs

If an interrupt _i_ is not present in the hardware, the corresponding CLIC register
locations appear hardwired to zero.

In S-mode, if an interrupt _i_ is not accessible to S-mode, the corresponding CLIC register
locations appear hardwired to zero.

==== `clicintattr[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg` register controls the clic priority setting of four interrupts
and each `sireg2` register controls the clic attribute setting of four interrupts

[%autowidth]
|===
| `siselect`   |  `sireg2` bits |  `sireg2` state          | description

| 0x1000+_i_   |   7:0        | RW  `clicintattr[_i_*4+0]` |  setting for interrupt _i_*4+0
| 0x1000+_i_   |  15:8        | RW  `clicintattr[_i_*4+1]` |  setting for interrupt _i_*4+1
| 0x1000+_i_   |  23:16       | RW  `clicintattr[_i_*4+2]` |  setting for interrupt _i_*4+2
| 0x1000+_i_   |  31:24       | RW  `clicintattr[_i_*4+3]` |  setting for interrupt _i_*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic attribute setting of eight interrupts.

==== `cliciprio[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg3` register controls the clic priority setting of four interrupts

[%autowidth]
|===
| `siselect` |  `sireg3` bits |  `sireg3` state              | description

| 0x1000+i   |   7:0          | RW  `cliciprio[__i__*4+0]` |  setting for interrupt __i__*4+0
| 0x1000+i   |  15:8          | RW  `cliciprio[__i__*4+1]` |  setting for interrupt __i__*4+1
| 0x1000+i   |  23:16         | RW  `cliciprio[__i__*4+2]` |  setting for interrupt __i__*4+2
| 0x1000+i   |  31:24         | RW  `cliciprio[__i__*4+3]` |  setting for interrupt __i__*4+3
|===

* When XLEN = 64, only the even-numbered registers exist and each register controls the clic priority setting of eight interrupts.

==== `clicintip[__i__]` and `clicintie[__i__]`

In this `siselect` offset range:

* When XLEN = 32, each `sireg` register reflects the interrupt pending of thirty-two interrupts.
and each `sireg2` register controls the interrupt enable of thirty-two interrupts.

[%autowidth]
|===
| `siselect`   |  `sireg` bits |  `sireg` state          |  `sireg2` bits |  `sireg2` state          | description

| 0x1400    |   31:0   | RW `clicintip[31:0]`      |   31:0    | RW `clicintie[31:0]`       | settings for interrupts 31 through 0
| 0x1401    |   31:0   | RW `clicintip[63:32]`     |   31:0    | RW `clicintie[63:32]`      | settings for interrupts 63 through 32
6*^| ...
| 0x147F    |   31:0   | RW `clicintip[4095:4064]` |   31:0    | RW `clicintie[4095:4064]`  | settings for interrupts 4095 through 4064
|===

* When XLEN = 64, only the even-numbered registers exist and each `sireg` register reflects the interrupt pending of sixty-four interrupts and
each `sireg2` register controls the interrupt enable of sixty-four interrupts.

=== New CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x???   sclaimi      Claim top interrupt
----

==== Claim top interrupt (sclaimi)

Register {sclaimi} has the same value as {stopi}.
When this value is not zero,
reading {sclaimi} has the simultaneous side effect of clearing the pending bit for the reported interrupt identity,
if possible.
Writes to {sclaimi} are ignored.

==== Interrupt enable threshold (smithreshold)

{sithreshold} is a WLRL register that determines the minimum interrupt priority (maximum priority
number) for an interrupt to be to be considered enabled.
Register {smithreshold} implements exactly IPRIOLEN bits,
and thus is capable of holding all priority numbers from 0 to latexmath:[${{2}^{\textrm{IPRIOLEN}} - {1}}$].
When {sithreshold} is a nonzero value P,
interrupt sources with priority numbers P and higher behave as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits.

== Horizontal Nested Interrupt Preemption support for M-mode - Smclic

The Smclic extension depends on the Smaia extension.

The Smclic extension enables higher priority interrupts to preempt a lower priority interrupts in a nested fashion.
It provides additional state to resume execution of the previous handler after a nested preemption.

=== Changed and new CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x346   mpintstatus  Previous interrupt context
 (NEW) 0xFB1   mintstatus   Current interrupt context
 (NEW) 0x347   mipreemptcfg Interrupt preemption configuration
----

==== New Interrupt Preemption Configuration ({mipreemptcfg}) CSR

[source]
----
mipreemptcfg fields
 bits        description
 XLEN-1:4    (reserved)
 3:0         preemptmsk

----

{mipreemptcfg} is a WARL register used to configure the behavior of preemption.
{mipreemptcfg}.{preemptmsk} configures the number of least significant bits of iprio masked out for constructing {nipprio}.
The highest legal value of {mipreemptcfg}.{preemptmsk} is IPRIOLEN.
The nested interrupt preemption priority {nipprio} is defined as follows:

[source]
----
NIPPRIO_MASK = ~(2^(mipreemptcfg.preemptmsk) - 1)
nipprio[i]   = iprio[i] & NIPPRIO_MASK
----

A nested horizontal preemption will happen if and only if an interrupt i is pending and enabled,
and the preemption priority of that interrupt nipprio[i] exceeds (i.e. is numerically smaller) than {mintstatus}.{mnipprio}.

Depending on the number of implemented priority bits, the maximum value of {nipprio} is

[source]
----
IPRIO_MAX  = 2^(IPRIOLEN)
NIPPRIO_MAX = IPRIO_MAX & NIPPRIO_MASK
----

In order to differentiate between regular and interrupt execution,
interrupts shall not be configured in a way, that {nipprio} equals NIPPRIO_MAX.

==== New Interrupt Status ({mpintstatus}) CSR

A new M-mode CSR, `mpintstatus`, holds consolidated state of preempted context.

[source]
----
mpintstatus 
Bits   Field           Description
 XLEN-1 Interrupt      Set to 1 for interrupts and 0 for exceptions.  Mirror of mcause.Interrupt
 30     (reserved)
 29:28  mpp[1:0]       Previous privilege mode, mirror of mstatus.mpp
 27     mpie           Previous interrupt enable, mirror of mstatus.mpie
 26:24  (reserved)
 23:16  mpnipprio[7:0] Previous nested interrupt preemption priority
 15:0   (reserved)
----

==== New Interrupt Status ({mintstatus}) CSR

A new M-mode CSR, `mintstatus`, holds the active nested interrupt preemption priority for
each supported privilege mode.  These fields are read-only.  The
primary reason to expose these fields is to support debug.

[source]
----
mintstatus fields
 bits    description
 31:24   mnipprio
 23:16   (reserved)
 15: 8   snipprio if Ssclic is supported
  7: 0   (reserved)
----

=== Reset Behavior

In general in RISC-V, mandatory reset state is minimized but platform
specifications or company policy might add additional reset
requirements.  Since the general privileged architecture states that
mstatus.mie is reset to zero, interrupts will not be enabled coming
out of reset.

==== Mandatory reset state

{mintstatus}.{mnipprio} and {mpintstatus}.{mpnipprio} fields reset to the highest possible value NIPPRIO_MAX.

The reset behavior of other fields is platform-specific.

=== Interrupt Operation

This section describes the operation of Smclic interrupts.

==== Trap behavior

The existing trap behavior for interrupts is modified as follows:

When a trap _i_ is taken,
the current value of {mintstatus}.{mnipprio} is written to {mpintstatus}.{mpnipprio}.
If the trap is taken on an interrupt, {mintstatus}.{mnipprio} is updated to `iprio[__i__]`.

NOTE: Synchronous exceptions do not modify the value of {mintstatus}.{mnipprio}.

==== Returns from Handlers

The behavior of an {mret} instruction is modified as follows:

{mret} sets {mintstatus}.{mnipprio} to {mpintstatus}.{mpnipprio}.

== Horizontal Nested Interrupt Preemption support for S-mode - Ssclic

The Ssclic extension depends on the Smclic and Ssaia extensions.
When S-mode and the Smclic extensions are implemnted, Ssclic is mandatory.

=== Changed and new CSRs

[source]
----
       Number  Name         Description
 (NEW) 0x146   spintstatus  Previous interrupt context
----

==== New Interrupt Status ({spintstatus}) CSR

[source]
----
spintstatus
 Bits    Field         Description
 XLEN-1 Interrupt      Interrupt=1, Exception=0, same as scause.Interrupt
 30:29  (reserved)
    28  spp            Previous privilege mode, same as sstatus.spp
    27  spie           Previous interrupt enable, same as sstatus.spie
 26:24  (reserved)
 23:16  spnipprio[7:0] Previous nested interrupt preemption priority
 15:0   (reserved)
----

The supervisor {scause} register has only a single `spp` bit (to
indicate user/supervisor) mirrored from {sstatus}.`spp`.

=== Reset Behavior

Nested interrupt preemption priority NIPPRIO_MAX corresponds to regular
execution outside of an interrupt handler.

NOTE: For an S-mode execution environment, the EEI should specify
that {sstatus}.`sie` is also reset on entry. It is then responsibility of
the execution environment to ensure that is true before beginning execution
in S-mode.

=== Interrupt Operation

This section describes the operation of Ssclic interrupts.
The behavior is modified in analogy to Smclic.

==== Trap behavior

When a trap _i_ is taken,
the current value of {sintstatus}.{snipprio} is written to {spintstatus}.{spnipprio}.
If the trap is taken on an interrupt, {sintstatus}.{snipprio} is updated to `iprio[__i__]`.

NOTE: Synchronous exceptions do not modify the value of {sintstatus}.{snipprio}.

==== Returns from Handlers

The behavior of an {sret} instruction is modified as follows:

{sret} sets {sintstatus}.{snipprio} to {spintstatus}.{spnipprio}.

==== State Enable

If the Smstateen extension is implemented, then the bit 53 (CLIC) in mstateen0 is
implemented. If bit 53 (CLIC) of a controlling mstateen0 CSR is zero, then
access to the new CSR ({sivt})
by S-mode or a lower privilege mode
results in an illegal instruction exception, except if the hypervisor
extension is implemented and the conditions for a virtual instruction
exception apply, in which case a virtual instruction exception is
raised when in VS or VU mode instead of an illegal instruction
exception.

== Support for far hardware vectored interrupts - Smclicivt

To increase the range of reachable addresses, this extension adds a new vectoring mode.
This is useful when handlers are more than 2 MiB away from the vector table entry.

In this new mode, when an interrupt is taken, the hart hardware loads the vector
table entry for the associated interrupt (table pointed to new {mivt} CSR),
masks off the least-significant bit (for IALIGN=16) or masks of the 2 least-significant bits (for IALIGN=32),
and then jumps to the masked address.

=== Smclicivt Changes to CLIC CSRs

=== Changed and new CSRs

[source]
----
       Number  Name         Description
       0x305   mtvec        Trap-handler base address / interrupt mode
 (NEW) 0x307   mivt         Interrupt-handler vector table base address
----

==== New {mivt} CSR

The {mivt} WARL XLEN-bit CSR holds the base address of the interrupt vector
table, aligned on a 64-byte or greater power-of-two boundary.
Values other than 0 in the low 6 bits of {mivt} are reserved.

NOTE: The actual alignment can be determined
by writing ones to the low-order bits
then reading them back.

==== New {mtvec} CSR Mode for CLIC

Far hardware vectored interrupt-handling mode is encoded as a new state in the
existing {mtvec} WARL register, where {mtvec}.`mode` (the two
least-significant bits) is `11`.

.xtvec register layout
include::images/wavedrom/xtvec.edn[]

==== Smclicivt Changes to {tvec} CSR Mode for CLIC

The PC upon interrupt is changed as follows:

[source]
----
 mode  PC on Interrupt
 00    OBASE                                # Direct mode
 01    OBASE+4*exccode                      # Vectored mode
 11    M[VTBASE+XLEN/8*exccode] & VTMASK    # Interrupt vector table mode
 10    Reserved

where:
  OBASE  = xtvec[XLEN-1:2]<<2   # Vector base is at least 4-byte aligned
  VTBASE = xivt[XLEN-1:6]<<6    # Interrupt Vector Table base is at least 64-byte aligned
  M[a]   = Contents of memory address at address "a"
  VTMASK = ~0x1 if IALIGN=16 or ~0x3 if IALIGN=32
----

In interrupt vector table mode, when interrupts are taken, the interrupt behavior is modified as follows:
After executing the required side-effects as required with the existing behavior,
the hart then fetches an XLEN-bit handler address with permissions corresponding to the handler's mode
from the in-memory table whose base address (VTBASE) is in {ivt}.
The trap handler function address is fetched from `VTBASE+XLEN/8*exccode`.
If the fetch is successful, the hart clears the low bit(s) (depending on IALIGN) of the handler address,
and sets the PC to this handler address.
The masked vector table entry bit(s) are reserved and should be zero.

The vector table layout will look like this for RV32 and RV64, respectively:

[source]
----
           # Vector table layout for RV32 (4-byte function pointers)
  mivt ->  0x800000 # Interrupt 0 handler function pointer
           0x800004 # Interrupt 1 handler function pointer
           0x800008 # Interrupt 2 handler function pointer
           0x80000c # Interrupt 3 handler function pointer

           # Vector table layout for RV64 (8-byte function pointers)
  mivt ->  0x800000 # Interrupt 0 handler function pointer
           0x800008 # Interrupt 1 handler function pointer
           0x800010 # Interrupt 2 handler function pointer
           0x800018 # Interrupt 3 handler function pointer
----

NOTE: The original vectored mode simply jumps to an address in
the trap vector table, while the interrupt vector table mode reads a
handler function address from the table, and jumps to it in hardware.

For permissions-checking purposes, the memory access to retrieve the
function pointer for hardware vectoring is an _implicit_ fetch at the
privilege mode of the interrupt handler, and requires execute
permission; read permission is irrelevant.
It is recommended that the vector table fetches are ignored for hardware triggers and breakpoints.

Memory writes to the vector table require an instruction barrier (_fence.i_) to guarantee that they are visible to the instruction fetch.

It is recommended that the second fetch be ignored for hardware triggers and breakpoints.

==== Vector table fault handling

Faults that occur during the fetch of interrupt vector table entries are only recoverable,
if the double trap extension(s) are implemented.
For interrupts in M-mode, this additionally requires the Smrnmi extension.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

In this case, if an exception trap occurs during the interrupt handler function address fetch,
the following holds true:
Depending on where the second trap is handled,
the corresponding exception pc ({mepc} or {mnepc}) value is set to the exception pc of the first trap.
In addition, {tval} is either set to zero or written with the faulting address.

NOTE: For simpler systems, we do not require that {tval} is written
with the faulting address.  For systems with demand paging, {tval}
should be written with the faulting address to simplify page-fault
handling code.

NOTE: After returning from handling the synchronous exception, another trap will happen immediately.
In case a higher priority interrupt became pending and enabled, this will trap first.

As long as synchronous exceptions can occur during the interrupt vector table fetch,
side-affects of the trap may only be executed if they allow resuming of operation after the handling of the synchronous exception.

NOTE: Resuming after a fault on a vector table fetch is currently only seen as useful for instruction page faults.

== Synchronous exceptions hardware vectoring- Smclicsehv

The Smclicsehv extension depends upon the Smclicivt extension.

Accelerating synchronous exception handlers through vectoring may reduce interrupt latency.
During synchronous exceptions, interrupts are disabled.
Acceleration of this critical segment decreases the time during which interrupts are masked.
Typical examples of synchronous exceptions that occur as part of normal program execution include traps due to ecalls, misaligned accesses, instruction page faults, or illegal instructions.

With this extension, synchronous exceptions are vectored using xtvec as an offset.
The summarized behavior is the following:

[source]
----
 mode  PC on Synchronous Exception
 00       OBASE              # Direct mode
 01       OBASE              # Vectored mode
 11       OBASE+4*exccode    # Far vectored mode
 10       Reserved
----

== Smcspsw Conditional Stack Pointer Swap extension

For security and stack safety reasons, it can be desired to separate the stack areas per privilege level and between traps and normal execution.
Performing stack pointer swaping in SW can be time consuming, as the conditions for swapping have to be checked first.
However, stack pointer swapping is among the first things that need to happen even before saving the interrupted context.
To ensure fast interrupt handling, this extension introduces an instruction to accelerate conditional stack pointer swapping.

==== CSR with stack pointer for conditional swap (msp)

A new CSR is introduced to hold an alternative stack pointer.
Conditionally, this stack pointer can be swapped with the currently active one.

[source]
----
      Number  Name         Description
(NEW) 0x348   msp          Stack pointer for conditional swap (WARL)
----

==== Instructions for conditional stack pointer swap

To simplify and accelerate the conditional stack pointer swap, two instructions are introduced, cspspush and cspspop.
To decide, if a stack pointer swap is required, these instructions assume that stack pointers,
which shall be swapped in during a push operation, have the LSb asserted.

NOTE: As per the RISC-V calling convention, stack pointers are 128b aligned, therefore the least significant bits are zero.

If the value of {msp} is zero, no conditional stack pointer swap is performed.

=== Sscsps Conditional Stack Pointer Swap at Supervisor Level

The Sscsps depends on the Smcsps extension.

It adds a new supervisor level CSR ssp.

[source]
----
      Number  Name         Description
(NEW) 0x148   ssp          Stack pointer for conditional swap (WARL)
----

At supervisor level, the cspspush and cspspop instructions operate on the {ssp} register.

=== State Enable

If the Smstateen extension is implemented, then the bit 53 (CLIC) in mstateen0 is
implemented. If bit 53 (CLIC) of a controlling mstateen0 CSR is zero, then
access to the new CSRs ({ssp})
by S-mode or a lower privilege mode
results in an illegal instruction exception, except if the hypervisor
extension is implemented and the conditions for a virtual instruction
exception apply, in which case a virtual instruction exception is
raised when in VS or VU mode instead of an illegal instruction
exception.

<<<

=== Instructions

==== cspspush

Synopsis::
Conditional stack pointer swap (push mode)

Mnemonic::
cspspush rd, rs

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs'], type: 4},
  {bits: 5, name: 0x9, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::

This instruction conditionally swaps out the stack pointer and is typically used while pushing existing context.
The stack pointer swap is conditionally executed, if xsp[0] is '1'.

The behavior of the operations is:

[source]
----
if xsp[0] == 1
    tmp = rd
    rd = xsp & ~1
    xsp = tmp
----

Included in: <<smcsps>>

<<<

==== cspspush

Synopsis::
Pop trap context

Mnemonic::
tpop

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x2, attr: ['rd'], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x2, attr: ['rs'], type: 4},
  {bits: 5, name: 0xC, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::

This instruction performs the opposite operation of cspspush, and is used to pop the previous context.
To ensure that cspspush can differentiate the stack pointers, the LSb is asserted when storing the value.

Behavior::

[source]
----
if xsp != 0
    tmp = xsp
    xsp = rs | 1
    rd = tmp
----

Included in: <<smcsps>>

<<<

[[smtp, Smtp]]
== Trap handler push and pop extension (Smtp)

The trap handler push and pop extension adds instructions to accelerate trap handling, which additionally reduce code size.
Trap handler latency and jitter is reduced by allowing the context save to happen speculatively in parallel to the vector table and handler fetch.
Additional latency reduction is achieved by allowing late-preemption of the push sequence in favor of a higher priority interrupt or synchronous exception.
Trap handling throughput is increased by allowing tail-chaing of interrupts or synchronous exceptions, skipping the context restore and save in between servicing two handlers.
The instructions are designed to be applicable to all RISC-V trap handling schemes.

=== Trap handler push and pop functional overview

1. The tpush instruction
* Conditionally performs a stack pointer swap by executing cspspush sp
* Saves hart's state of the preempted context that can be overwritten in case of a nested preemption
* Save registers x10-x15 (these are the caller saved registers available in RVC)
* Adjusts the stack pointer to create the stack frame
* Clear the ip bit if writable
* Write trap information to argument registers
* Optionally, enable interrupts and clear the xstatus.XDT flag if the double trap extension is implemented at the current privilege level

NOTE: If a trap occurs during the sequence, then any operations which were executed before the trap may update architectural state and/or memory contents.
The preempting trap is expected to fully save and restore the architectural state that it overwrites.
If the trap occurs before updating the stack pointer, it needs to be assumed that the stacked context was overwritten.
In this case, if the instruction is resumed, any store operations must be re-executed.

The tpush instruction writes the value of the xcause CSR into register a0.
This is beneficial also with vectored interrupts, as it allows sharing the same handler for similar interrupt sources.
For example, if a peripheral exists multiple times in a system at different offsets, this can be handled with one handler.

The following table summarizes the written trap information:

[%autowidth]
|===
| Register | synchronous exception | interrupt
| a0       | xcause | xcause
| a1       | xtval | no write
| a2       | xtval2 | no write
| a3       | xtinst | no write
|===

Software shall only use the information from the argument registers, as the corresponding CSRs may be overwritten by preempting traps.
The values of xtval, xtval2, and xinst only need to be written to an argument register if the corresponding exception cause a write to the respective CSR.

2. The tpopxret instruction
* Disables interrupts
* Set the xstatus.XDT flag if the double trap extension is implemented at the current privilege level
* Restores registers x10-x15
* Restores the the hart's state to the point that the hart can return to the interrupted context
* Adjust the stack pointer to destroy the stack frame
* Conditionally performs a stack pointer swap by executing cspspop sp
* Executes an xret according to the current level

NOTE: If a trap occurs during the sequence, then any operations which were executed before the trap may update architectural state.
A trap may not occur after updating the stack pointer, if the context was not yet fully restored from the stack.

There is no specific order mandated for the context save/restore, and the individual parts may occur in parallel.
Interrupts shall not be enabled before completing the context save/restore operations of the tpush instruction.
Interrupts must be disabled before starting to restore context in the tpopxret instruction.
As interrupts are disabled during the sequence as a side effect of the trap being taken, intermediate states during the execution of the instruction are not observable.

If the Smtp extension is implemented, the first and last instructions of a trap handler must be a tpush and the last a tpopxret instruction, respectively.

NOTE: In contrast to the Zcmp push/pop intructions, Smtp instructions do not encode an incremental stack pointer adjustment in order to ease late preemption and tail chaining.

With these requirements, implementations are allowed to speculatively start executing an tpush instruction in case of a taken interrupt.

=== Late Preemption of the interrupt handler

While executing the tpush instruction, a hart may optionally check for higher priority pending and enabled interrupts at the current privilege mode, and switch to fetching this trap handler instead.
Once the instruction retires, or the interrupts are disabled, no late preemption can occur.

=== Tail chaining of interrupts handlers

While executing the tpopxret instruction, a hart may optionally check for any pending and enabled interrupts at the current privilege mode.
If such an interrupt exists, the hart may abort executing the tpopxret instruction and trigger the following actions:
  - Update the xcause.exccode to the corresponding interrupt id.
  - Perform the trap handler fetch.
  - Start excuting the trap handler, while skipping the portions of tpush that have not been reverted by the aborted tpopxret.

Explicitly, xepc, xpil, and xpp remain unchanged.

NOTE: In the typical case of tail chaining, the check for another pending enabled interrupt is done after disabling interrupts at the start of the tpopxret instruction. In this case, only the conditional interrupt enablement of the tpush instruction would need to executed.

Once the instruction retires, or the interrupts are disabled, no late preemption can occur.

=== Stack layout

To ease debugging, a stack layout is recommended for the saved context.

NOTE: This stack layout is not mandated to allow e.g. shadow register sets

[source]
----
* Smclic/Ssclic not present:

** XLEN = 32:

stack pointer adjustment: 32

24: x15
20: x14
16: x13
12: x12
8: x11
4: x10

** XLEN = 64:

stack pointer adjustment: 48

48: x15
40: x14
32: x13
24: x12
16: x11
8: x10

* Smclic/Ssclic present:

start of stackframe remains same. In addition:

** XLEN = 32

stack pointer adjustment: 32

32: xpintstatus (XLEN)
28: xpepc (XLEN)

** XLEN = 32

stack pointer adjustment: 64

60: xpintstatus (XLEN)
56: xpepc (XLEN)
----

=== Fault handling

Unless it can be guaranteed by design that faults causing synchronous exceptions cannot occure during the critical section,
handling can only be resumed if the double trap extension is supported.
The critical sections are defined as the time during execution of the tpush and tpopxret instruction, during which interrupts are disabled.

=== Debug

As the execution of tpush may start before the instruction is fetched, breakpoint conditions met might observe an inconsistent state.
Therefore, if a breakpoint is triggered because of an tpush instruction, the breakpoint shall be handled as if it occured on the subsequent instruction.

<<<

=== Instructions

==== tpush

Synopsis::
Push trap context

Mnemonic::
tpush preempt

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 4},
  {bits: 4, name: 0x7, attr: [''], type: 8},
  {bits: 1, name: 'imm1', attr: ['preempt'], type: 3},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::
Saves the interrupted context at the beginning of a trap.
If preempt is '1', interrupts will be enabled at the end of the sequence.

Behavior::

The behavior in RISC-V asssembly when preempt is '1' is as follows.
If preempt is '0', enabling interrupts shall be skipped.
The behavior is assuming Smclic is present. Otherwise, xintstatus will not be saved.

[source]
----
push:
  cspspush sp, sp           # Conditionally swap stack pointer
  addi sp, sp, -FRAMESIZE   # Adjust stack pointer
  sr a0, OFFSET(sp)         # Save a0
  sr a1, OFFSET(sp)         # Save a1
  sr a2, OFFSET(sp)         # Save a2
  sr a3, OFFSET(sp)         # Save a3
  sr a4, OFFSET(sp)         # Save a4
  sr a5, OFFSET(sp)         # Save a5
  sr a6, OFFSET(sp)         # Save a6
  csrr a0, xcause           # Get xcause of interrupted context
  csrr a4, xepc             # Get xepc of interrupt context
  csrr a5, xintstatus       # Get xintstatus of interrupt context
  sr a4, OFFSET(sp)         # Save xepc
  sr a5, OFFSET(sp)         # Save xintstatus
  bgez a0, handle_exc       # Handle synchronous exception
  csrr zero, xclaimi        # Clear ip bit of interrupt if possible
finish_push:
  csrrsi zero, xstatus, XIE # Enable interrupts

handle_exc:
  csrr a1, xtval            # Get xcause of interrupted context
  csrr a2, xtval2           # Get xepc of interrupt context
  csrr a3, xtinst           # Get xintstatus of interrupt context
  j finish_push             # Jump back to rest of push sequence

where
  sr is sw on RV32 and sd on RV64
  lr is lr on RV32 and ld on RV64
----

Included in: <<smtp>>

<<<

==== tpopxret

Synopsis::
Pop trap context

Mnemonic::
tpop

Encoding::
[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 0x73, attr: ['SYSTEM'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 2},
  {bits: 3, name: 0x0, attr: ['PRIV'], type: 8},
  {bits: 5, name: 0x0, attr: [''], type: 4},
  {bits: 5, name: 0x8, attr: [''], type: 8},
  {bits: 7, name: 0x8, attr: [''], type: 8},
]}
....

Description::
Restores an interrupted context at the end of a trap.

Behavior::

The behavior in RISC-V asssembly is as follows.
The behavior is assuming Smclic is present. Otherwise, the xintstatus CSR will not be restored.

[source]
----
pop:
  csrrsi zero, xstatus, XIE # Disable interrupts
  lr a4, OFFSET(sp)         # Restore xepc
  lr a5, OFFSET(sp)         # Restore xintstatus
  csrw xepc, a4             # Write xepc back to CSR
  csrw xintstatus, a5       # Write xintstatus back to CSR
  lr a0, OFFSET(sp)         # Restore a0
  lr a1, OFFSET(sp)         # Restore a1
  lr a2, OFFSET(sp)         # Restore a2
  lr a3, OFFSET(sp)         # Restore a3
  lr a4, OFFSET(sp)         # Restore a4
  lr a5, OFFSET(sp)         # Restore a5
  lr a6, OFFSET(sp)         # Restore a6
  addi sp, sp, FRAMESIZE    # Adjust stack pointer
  cspspop sp, sp            # Swap stack pointer with xsp
  xret

where
  sr is sw on RV32 and sd on RV64
  lr is lr on RV32 and ld on RV64
----

Included in: <<smtp>>
