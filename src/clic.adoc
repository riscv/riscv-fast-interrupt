:sectnums:
:toc: left

:cliccfg: pass:q[``**__x__**cliccfg``]
:status: pass:q[``**__x__**status``]
:ideleg: pass:q[``**__x__**ideleg``]
:ie: pass:q[``**__x__**ie``]
:tvec: pass:q[``**__x__**tvec``]
:tvt: pass:q[``**__x__**tvt``]
:scratch: pass:q[``**__x__**scratch``]
:scratchcsw: pass:q[``**__x__**scratchcsw``]
:scratchcswl: pass:q[``**__x__**scratchcswl``]
:epc: pass:q[``**__x__**epc``]
:cause: pass:q[``**__x__**cause``]
:tval: pass:q[``**__x__**tval``]
:ip: pass:q[``**__x__**ip``]
:nxti: pass:q[``**__x__**nxti``]
:intstatus: pass:q[``**__x__**intstatus``]
:intthresh: pass:q[``**__x__**intthresh``]

:pp: pass:q[``**__x__**pp``]
:pie: pass:q[``**__x__**pie``]
:il: pass:q[``**__x__**il``]

:pil: pass:q[``**__x__**pil``]
:inhv: pass:q[``**__x__**inhv``]

:ret: pass:q[``**__x__**ret``]

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;


[[riscv-doc-template]]
= Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions
include::../docs-resources/global-config.adoc[]
:docgroup: RISC-V Task Group
:description: RISC-V Example Specification Document (Zexmpl)
:revdate: 1/2023
:revnumber: 1.0
:revremark: This document is under development. Expect potential changes. Visit http://riscv.org/spec-state for further details.
:revinfo:
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
// https://docs.asciidoctor.org/asciidoc/latest/macros/images-directory/
:imagesdir: ../docs-resources/images
:title-logo-image: image:risc-v_logo.png["RISC-V International Logo",pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
//:WaveDromEditorApp: app/wavedrom-editor.app
:imagesoutdir: images
//:srcdir: src
:bibtex-file: src/example.bib
:bibtex-order: alphabetical
:bibtex-style: apa
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:toc: left
:toclevels: 4
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short


Graphics used are either explicitly available for free, are property of RISC-V International, or were created using Wavedrom.

:status: pass:q[``**__x__**status``]
:ideleg: pass:q[``**__x__**ideleg``]
:ie: pass:q[``**__x__**ie``]
:tvec: pass:q[``**__x__**tvec``]
:tvt: pass:q[``**__x__**tvt``]
:scratch: pass:q[``**__x__**scratch``]
:scratchcsw: pass:q[``**__x__**scratchcsw``]
:scratchcswl: pass:q[``**__x__**scratchcswl``]
:epc: pass:q[``**__x__**epc``]
:cause: pass:q[``**__x__**cause``]
:tval: pass:q[``**__x__**tval``]
:ip: pass:q[``**__x__**ip``]
:nxti: pass:q[``**__x__**nxti``]
:intstatus: pass:q[``**__x__**intstatus``]
:intthresh: pass:q[``**__x__**intthresh``]

:pp: pass:q[``**__x__**pp``]
:pie: pass:q[``**__x__**pie``]
:il: pass:q[``**__x__**il``]

:pil: pass:q[``**__x__**pil``]
:inhv: pass:q[``**__x__**inhv``]

:ret: pass:q[``**__x__**ret``]

:le: &#8804;
:ge: &#8805;
:lt: &#60;
:gt: &#62;

// SPDX-License-Identifier: CC-BY-4.0
//
// licensing.adoc: licensing information
//
// Copyright and licensing information for the specification.
//

[Preface]
== Copyright and license information

This RISC-V CLIC specification is © 2018-2024 RISC-V international

This document is released under a Creative Commons Attribution 4.0
International License. +
https://creativecommons.org/licenses/by/4.0/.

Please cite as: “Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extensions",  RISC-V International

This document is a derivative of the "The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document
version 1.9.1" released under following license: © 2010–2017 Andrew Waterman,
Yunsup Lee, Rimas Aviˇzienis, David Patterson, Krste Asanovi ́c.
Creative Commons Attribution 4.0 International License.

[Preface]
== Revision History

[source]
----
Date        Description
09/10/2024  issue #411 - Clarify that smclicshv ignores 1 or 2 LSBs of vector table entry (depending on IALIGN)
09/10/2024  pull  #404 - First round of reorganization of the document to move SW information to Appendix
08/30/2024  issue #401 - First round of changes to improve clarity of document. Removed mention of U-mode interrupts.
03/14/2024  issue #391 - Allocated indirect CSR numbers 0x1000-0x14A0 for clicint regs
03/08/2024  issue #385 - Add WARL note to clicintctl/clicintattr/clicintie
03/05/2024  issue #388 - Fix clicintctl/clicintattr miselect/siselect values
03/05/2024  issue #377 - Clarify indirect CSR access text
03/05/2024  issue #383 - Rename title of m-mode indirect csr access
03/05/2024  issue #381/379 - revert pull #370 merge. xnxti again does not return SHV trap-handler entries.
03/05/2024  issue #380 - Fix clicintctl spelling
03/04/2024  issue #349 - Change access to CLIC registers from memory mapped to indirect CSR
03/04/2024  pull #369  - Redefine parameters to no longer specify number of bit implemented but instead specify legal WARL values.
03/04/2024  pull #373  - Add xcause.xpil fields to mandatory reset state.
03/04/2024  issue #371 - Add additional clicinttrig enable for signaling interrupts claimed by xnxti.
03/04/2024  issue #314 - xnxti now also returns SHV trap-handler entries
02/09/2024  issue #360 - CLIC is allocated bit 53 in the stateen0 registers with the presumed bit name of CLIC.
02/09/2024  issue #91  - Removed incorrect DTS entry. Moving DTS entry task to spike issue #242 instead of being in CLIC spec.
02/05/2024  issue #367 - clicintip/ie clarification
12/19/2023  issue #303 - Clarify behavior of CSRs when switching between CLIC and CLINT modes
10/10/2023  issue #307 - NUM_INTERRUPT parameter text cleanup
10/10/2023  issue #355 - updated text clarifying clic interaction with rnmi spec
10/10/2023  issue #347/356/357/358 - updated mret/inhv pseudo-code
09/01/2023  issue #339 - typo changed xstatus.il to xintstatus.il
08/29/2023  issue #345 - stateen register required to block access to new ssclic CSRs?
08/29/2023  issue #350 - clarify which privilege modes will have mscratchcsw
08/29/2023  issue #351 - Clarify/Fix Smclic Ssclic Suclic memory map reserved areas
08/01/2023  issue #333 - xcause.xinhv - x is the faulting priv, i.e., when set, xinhv indicates is xepc is addr of a table entry.
06/20/2023  issue #339 - updated text describing mcause.pil and xret behavior to better match wording in priv spec
06/06/2023  issue #334 - removed text regarding debug changes to xintthresh as this does not apply #334
05/30/2023  spelling fixes.
05/09/2023  issue #317 - clarification that trampoline examples do not account for f or v registers
05/09/2023  issue #322 - xcliccfg xnlbits text cleanup
05/09/2023  issue #321 - intthresh clearing/zeroing text changed to setting to min value
05/09/2023  issue #320 - RNMI CSR CLIC details added
04/11/2023  issue #318 - use zero instead of x0 in assembly examples.
04/11/2023  issue #290 - force xepc to have table-entry alignment on xRET during inhv
03/28/2023  issue #311 - provided separate unlbits/snlbits/mnlbits in separate cliccfg registers per mode.  This changes the cliccfg bit ordering.
03/28/2023  issue #304 - clean up VM page boundary alignment recommendations
03/28/2023  issue #295 - also include DRET in clearing intthresh
03/28/2023  issue #315 - typo fix in interrupt handler example
03/14/2023  issue #309 - Added discussion on NMI and RNMI handling.
03/14/2023  issue #295 - MRET/SRET clears current priv intthresh when going to a lower priv mode.
02/28/2023  issue #305 - clean up xideleg and xedeleg text
02/14/2023  pull #302 - make clicinttrig, xnxti/xscratchcsw/xscratchcswl non-optional
02/14/2023  issue #293 - create separate cliccfg per priv mode
02/14/2023  issue #294 - Change addresses of mintstatus, sintstatus, uintstatus to  0xFB1, 0xDB1, and 0xCB1, respectively.
02/14/2023  issue #298 - typo cleanup - removed redundant note text in smclicshv section
01/31/2023  issues #75/#160 - reordered text into 5 extensions, smclic, ssclic, suclic, smclicshv, smclicconfig. No functional changes intended.
11/08/2022  issue #271 - text cleanup - updated inhv to xinhv
11/08/2022  issue #280 - clarified nxti CSR access types
11/08/2022  issue #235 - clarified inhv text for statement when a trap is taken all cause fields are updated.
11/08/2022  issue #88/#282 - moved xintstatus to read-only CSR addr range, moved clicbase, nvbits, clicinfo to parameters section
10/25/2022  issue #274 - clarify handling of horizontal traps on table fetch in pseudo-code
10/25/2022  issue #277 - be consistent in calling CLIC inputs local interrupts.
10/11/2022  issue #275 - clarify hwvector text
10/11/2022  issue #279 - Reserved use of all but simple csrrw access to scratchcsw/l, clarified operation of the instruction
10/11/2022  issue #277 - Added more clarification on csip
09/27/2022  issue #271/#272 - xinhv text cleanup. setting ucause_inhv in pseudo-code when u-mode not implemented.
09/27/2022  issue #240/#255 - clarify CLIC vs CLINT mode settings
09/13/2022  issues #219/#222 - CLIC interrupt ordering text clarifications.
09/05/2022  issue #267 - update text from not defined to implementation-defined.
08/30/2022  clarify hw vectoring execute permissions,
            fixed text to say priv level instead of interrupt level.
            changed implicit read to implicit fetch.
08/30/2022  issue #219 - csip interrupt ordering clarification - CSIP interrupt ID was changed from 12 to 16
08/30/2022  issue #229 - clarify clicintattr.mode WARL behavior
08/30/2022  Define CLINT and replace references to "original basic local interrupts" with CLINT
08/30/2022  issue #191 - software vectoring read permission clarification
08/30/2022  issue #239/228 - clarification of breakpoints on hw vector table fetches, dpc
08/16/2022  issue #202 - 64-bit writes to {clicintctl,clicintattr,clicintie,clicintip} text clarification
08/02/2022  issue #250 - Clarified that not all specified CSRs are available in all privilege modes
08/02/2022  issue #248 - created a new xtvec submode field in clic mode
08/02/2022  issue #100 - reserving use of uimm bits in xnxti for future use
07/05/2022  Specified that xtvec.mode bits are writeable but hidden when in CLINT mode
06/21/2022  clarified "cleared" means set to 0 for interrupt pending bit
06/21/2022  issue #220 - reserved address space clarification (pull #243)
06/21/2022  issue #214 - xscratch pseudocode clarification (pull #215)
06/21/2022  issue #197 - Clarified xinhv pseudocode (pull #198)
06/21/2022  Made clear that mtvec[5:0]=000010 is still reserved
06/07/2022  pull #217 - allow implementing less than 8 bits for xintthresh
06/07/2022  issue #29/#155 (pull#190) - clarify clicinttrig details
06/07/2022  issue #212/pull#216 - fixed parameter value ranges for NUM_INTERRUPT and CLICMTVECALIGN
06/07/2022  Pull #218 - typo fix. clicintattr regs are used to delegate interrupts
06/01/2022  Wording change in comparison with AIA features.  Added reference to Bibliography.
05/10/2022  issue #235 - change “exception” to “trap” to match priv spec wording.
05/10/2022  issue #233 - mnxti pseudo-code clarification (added meaning of clic.priv,clic.level,clic.id)
05/10/2022  issue #225 - bounded time to respond to interrupts
04/26/2022  issue #191 - hw vector fetch permission changed to implicit read with execute permission required.
04/26/2022  issue #223/224 - mtval=0 allowed, hw vect xepc difference noted.
03/15/2022  issue #207 - further xret/inhv text clarification
03/06/2022  issue #210 - hw vector trap text clarification
02/15/2022  WFI text clarification
02/01/2022  issue #193 - xret/inhv text clarification
01/04/2022  issue #45 - remove new alignment constraint on CLINT mode when CLIC added
01/04/2022  issue #188 - clarification that writes to xcause affect xstatus
12/21/2021  issue #109 - add smclic arch string to spec
12/21/2021  issue #180 - change processor references to hart
11/09/2021  issue #48 - indicate when edge-triggered interrupts are cleared
11/09/2021  issue #179 - set interrupt bit during nxti access
10/28/2021  issue #154 - inhv clarification
10/28/2021  issue #31/#120 - wfi clarification
10/12/2021  issue #177 - Reduced mandatory reset requirements
09/29/2021  Added link to development states definition on top page
09/14/2021  pull #169 - nxti clarification
09/14/2021  pull #168 - only 0 or 8 level bits currently supported (other values reserved)
09/14/2021  issue #170 - clarified position of intthresh in CSR
08/31/2021  issue #86/#165 - Update mnxti pseudo-code to handle side-effects correctly.
08/31/2021  pull #164 - moved clicintattr.mode reset value to reset section of spec
08/17/2021  pull #163 - spec clarification that clicintie is held in bit 0 of byte.
07/20/2021  pull #161 - spec clarification that only writes to xnxti have side effects.
07/06/2021  issue #156,#77,#79 - more CLIC memory mapped text clarifications, clicintctl typo fixes
06/22/2021  issue #156 - reverted text and added clarification on CLIC memory mapped privilege regions.
05/25/2021  issue #149 - added text that 32-bit writes are legal but effects are not defined.
05/25/2021  issue #142 - added text that MPRV and SUM are obeyed on vector table accesses.
05/11/2021  issue #154 – added text that clarifies behavior when inhv is set when returning from a ret instruction.
04/27/2021  clicintip[i] state is undefined when switching from level to edge triggered mode
04/22/2021  updated adoc format to align with risc-v template, added revision history
04/18/2021  Added Bibliography section
04/15/2021  issue #45 - for rev1.0 mtvec not xtvec controls enabling CLIC mode for all priv
04/13/2021  issue #141 - N-extension vs Bare S-mode note added.
04/13/2021  issue #117,#125 fix - change text to match table in M/S/U system if nmbits==1
04/12/2021  issue #47 fix - add CLIC reset behavior section
04/12/2021  issue #26 fix - modify wording that defined micro-architectural behavior of xINHV
04/12/2021  issue #91 - add DTS entry example
04/12/2021  added CLIC comparison to Advance Interupt Architecture (AIA)
04/12/2021  issue #111,#105 fix - For hardware vectoring access exceptions, both {tval} and {epc} holds the faulting address
04/08/2021  issue #49, #79 - downplay M/S/U memory map requirements
03/30/2021  issue #29 - updated memory map table reserved section to give room for clicinttrig
03/30/2021  issue #122 fix - remove wording referring to register
03/11/2021  issue #120 - update WFI wording
03/11/2021  typo fixing
03/11/2021  issue #51 - implementation of non CSRRW variants of xscratchcsw/xscratchcswl explicitly not defined/reserved.
03/11/2021  issue #58 - xintthresh was missing from table summarizing overall interrupt behavior
02/17/2021  issue #95 fix - removed N extension reference since not ratified.
02/17/2021  issue #90 fix - clarified that clicintip!=0 means interrupt pending
02/17/2021  issue #89 - updated CLIC interrupt ID ordering recommendations
02/17/2021  ihnv clarification - inhv bit has no effect except when returning from a trap using an {ret} instruction
02/17/2021  ihnv clarification - inhv only written by hw during table vector read. can be written by software.
02/02/2021  WFI wording change
01/19/2021  WFI wording change
01/07/2021  WFI section added
01/07/2021  Notes added clarifying clicintie and mstatus.xie
01/07/2021  interrupt priority clarification
12/17/2020  Added support for interrupt triggers
10/20/2020  clarified differences between level and priority
10/20/2020  fixed value range for CLICINTCTLBITS
10/20/2020  Clarified relationship among interrupt level, cliccfg.nlbits and CLICINTCTLBITS
09/08/2020  clarified description for interrupt level
----

== Background and Motivation

The Core-Local Interrupt Controller (CLIC) Privileged Architecture Extensions are designed to provide
low-latency, vectored, pre-emptive interrupts for RISC-V systems.
When activated the CLIC subsumes and replaces the original RISC-V
basic local interrupt scheme (known as the CLINT in this document).
The CLIC has a base design that requires minimal hardware, but supports
additional extensions to provide hardware acceleration.  The goal of
the CLIC is to provide support for a variety of software ABI
and interrupt models, without complex hardware that can impact
high-performance implementations.

The CLIC also supports a Selective Hardware Vectoring extension that
allow users to optimize each interrupt for either faster response or
smaller code size.

NOTE: While the current CLIC provides only hart-local interrupt
control, future extensions might also support directing interrupts to
harts within a core, hence the name (also CLIC sounds better than HLIC
or HIC).

NOTE: CLIC only replaces the original RISC-V basic local interrupt scheme.  Exception behavior is unchanged.

=== Original RISC-V basic local Interrupts (CLINT mode)

The RISC-V Privileged Architecture specification defines CSRs such as {ip}, {ie} and interrupt behavior.
A simple interrupt controller that provides inter-processor interrupts and timer
functionalities for this RISC-V interrupt scheme has been called CLINT.
This specification will use the term CLINT mode when {tvec}.mode is set to either `00` or `01`.

CLINT mode supports interrupt preemption, but only based on privilege mode.  At any point in time, a
RISC-V hart is running with a current privilege mode.  The global
interrupt enable bits, {status}.{ie}, control whether
interrupts can be taken for the current or higher privilege modes;
interrupts are always disabled for lower-privileged modes.  Any
enabled interrupt from a higher-privilege mode will stop execution at
the current privilege mode, and enter the handler at the higher
privilege mode.  Each privilege mode has its own interrupt state
registers, e.g. `mepc`/`mcause` for M-mode and `sepc`/`scause` for S-mode, to support preemption, or
generically {epc}/{cause} for privilege mode ``*_x_*``.  Preemption by a
higher-privilege-mode interrupt also pushes current privilege mode and
interrupt enable status onto the {pp} and {pie}
stacks in the {status} register of the higher-privilege mode.

The {tvec} register specifies both the interrupt mode and the base
address of the interrupt vector table.  The low bits of the WARL
{tvec} register indicate what interrupt model is supported.  The
CLINT mode settings of {tvec} mode (`*00` and `*01`) indicate use of the
basic interrupt model with either direct or vectored transfer to a handler
function, with the 4-byte (or greater) aligned table base address held
in the upper bits of {tvec}.

NOTE: WARL means "Write Any, Read Legal" indicating that any value can
be attempted to be written but only some supported values will actually
be written.

NOTE: The settings of {tvec} mode with the value of `11` and a newly defined {tvec} submode field with the value of `0000` indicate CLIC modes instead of CLINT modes.  Refer to the {tvec} section in this specification for details.

=== CLIC mode compared to CLINT mode

A CLINT mode interrupt controller is a small unit
that provides local interrupts and manages
the software, timer, and external interrupt signals
(``**__x__**sip``/``**__x__**tip``/``**__x__**eip`` signals in
the {ip} register).  This basic controller also allows additional
custom fast local interrupt signals to be added in bits 16 and up of the
{ip} register.

Priority for local interrupts is fixed.  {tvec} mode can be set so that all interrupts are direct and set the pc to the same vector base address.  {tvec} mode can also be set so that all interrupts are vectored using a vector table filled with jump instructions.

CLIC allows software to control interrupt mode, trigger type, priority, and a CLIC mode vectoring behavior for each individual interrupt.  The CLIC mode vector table holds addresses so does not have the +/-1MiB jump instruction limitation.  CLIC adds support for same privilege mode interrupt preemption (horizontal interrupts) and additional support to reduce the number of memory or CSR accesses within an interrupt handler.

Platform profiles may
require support for either or both of the CLINT and CLIC interrupt modes.

=== CLIC compared to PLIC

The standard RISC-V platform-level interrupt controller (PLIC)
provides centralized interrupt prioritization and routes shared
platform-level interrupts among multiple harts, but sends only a single external interrupt
signal per privilege mode to each hart.

The PLIC routing scheme uses a notification/claim/response/completion sequence to route interrupts to individual harts which requires additional interrupt handler memory accesses.

The CLIC complements the PLIC.  Smaller single-core systems might have
only a CLIC, while multicore systems might have a CLIC per-core and a
single shared PLIC.  The PLIC ``**__x__**eip`` signals are treated as
hart-local interrupt sources by the CLIC at each core.

=== CLIC compared to Advanced Interrupt Architecture

Advanced interrupt Architecture (AIA) supports message-signaled interrupts (MSIs) and an Advanced PLIC (APLIC) and targeted to support multiple harts, and support for virtualization.  Like CLIC, the relative priority of all interrupts (not just external) can be configured. CLIC is targeted at CLIC per-core and has the option to give each interrupt source a separate trap entry address,  preemption (nesting) of interrupts with adjustable priority threshold control, and support for reduced context switching with back-to-back interrupts.

== CLIC Overview

This section gives an overview for the Core-Local Interrupt
Controller (CLIC) that receives interrupt signals and presents the next
interrupt to be processed by the hart.

The CLIC supports up to 4096 interrupt inputs per hart.
Each interrupt input _i_ has four control
registers: an interrupt-pending bit (`clicintip[__i__]`),
an interrupt-enable bit (`clicintie[__i__]`), interrupt attributes
(`clicintattr[__i__]`) to specify privilege mode and trigger type,
and interrupt control bits to specify level
and priority (`clicintctl[__i__]`).

When the first 16 interrupt inputs are reserved for the CLINT mode
interrupts present in the low 16 bits of the {ip} and {ie} registers,
up to 4080 local interrupts can be added.

=== Interrupt Preemption

The CLIC extends interrupt preemption to support up to 256 interrupt
levels for each privilege mode, where higher-numbered interrupt levels
can preempt lower-numbered interrupt levels.  Interrupt level 0
corresponds to regular execution outside of an interrupt handler.
Levels 1--255 correspond to interrupt handler levels. Platform
profiles will dictate how many interrupt levels must be supported.

Incoming interrupts with a higher interrupt level can preempt an
active interrupt handler running at a lower interrupt level in the
same privilege mode, provided interrupts are globally enabled in this
privilege mode.

NOTE: Existing RISC-V interrupt behavior is retained, where incoming
interrupts for a higher privilege mode can preempt an active interrupt
handler running in a lower privilege mode, regardless of global
interrupt enable in lower privilege mode.

=== CLIC Interaction with Other Local Interrupts

The CLIC subsumes the functionality of the basic local interrupts
previously provided in bits 16 and up of {ip}/{ie}, so these are no
longer visible in {ip}/{ie}.

The existing timer (`mtip`/`stip`), software
(`msip`/`ssip`), and external interrupt inputs
(`meip`/`seip`) are treated as additional local interrupt
sources, where the privilege mode, interrupt level, and priority can
be altered using `clicintattr[__i__]` and
`clicintctl[__i__]` registers.

NOTE: In CLIC mode, interrupt delegation for these signals is achieved
via changing the interrupt's privilege mode in the CLIC Interrupt
Attribute Register (`clicintattr`), as with any other CLIC
interrupt input. The mideleg CSR (if present) no longer controls interrupt delegation.

=== CLIC Extensions Summary

This table provides a summary of the extensions supported by the CLIC.

[%autowidth]
|===
| Extension Name | Description

| smclic | CLIC support for M-mode
| ssclic | CLIC support for S-mode
| smclicshv | Selective Hardware Vectoring for M-mode
| smclicconfig | Allows implementations to support different parameterizations of CLIC extensions
|===




== smclic M-mode CLIC extension

=== CLIC Level/Priority Control

==== Specifying Interrupt Level

A parameterized number of upper bits in
`clicintctl[__i__]` are assigned to encode the interrupt level.

NOTE: Implementations may choose to make CLIC parameters configurable prior to operation.

==== Specifying Interrupt Priority

The least-significant bits in `clicintctl[__i__]` that are not
configured to be part of the interrupt level are interrupt priority,
which are used to prioritize among interrupts pending-and-enabled at
the same privilege mode and interrupt level. The highest-priority
interrupt at a given privilege mode and interrupt level is taken first.
In case there are multiple pending-and-enabled interrupts at the
same highest priority, the highest-numbered interrupt is taken first.

NOTE: The highest numbered interrupt wins in a tie (when
privilege mode, level and priority are all identical). This is the same
as in CLINT interrupt mode, but different than the PLIC.

Notice that the 8-bit interrupt level is used to determine preemption
(for nesting interrupts). In contrast, the 8-bit interrupt priority
does not affect preemption but is only used as a tie-breaker
when there are multiple pending interrupts with the same interrupt level.

=== CLIC Interrupt Pending (`clicintip`)

Each interrupt input has a dedicated interrupt pending bit
(`clicintip[__i__]`).
Software should assume `clicintip[__i__]=0` means no interrupt pending, and
`clicintip[__i__]=1` indicates an interrupt is pending.

The conditions for an interrupt trap to occur must be evaluated in a bounded amount of time
from when an interrupt becomes, or ceases to be, pending in `clicintip`, but unlike the MIP/MIE CSRs, there is no requirement that clicintie or clicintip are evaluated immediately following an explicit store to `clicintip` or `clicintie`.

When the input is configured for level-sensitive input, the
`clicintip[__i__]` bit reflects the value of an input signal to the
interrupt controller after any conditional inversion specified by the
`clicintattr[i]` field, and software writes to the bit are ignored.
Software clears the interrupt at the source device.

When the input is configured for edge-sensitive input,
`clicintip[__i__]` is a read-write register that can be updated both
by hardware interrupt inputs and by software.  The bit is set by
hardware after an edge of the appropriate polarity is observed on the
interrupt input, as determined by the `clicintattr[i]` field.
Software writes to `clicintip[__i__]` can set or
clear edge-triggered pending bits directly by writes to the

`clicintip[__i__]` register. Edge-triggered pending bits can also be cleared when a CSR instruction that accesses {nxti} includes a write.
`clicintip[__i__]` behavior is unaffected by `clicintie[__i__]` setting.


NOTE: Software is expected to use a CSR instruction that accesses {nxti} that includes a write to clear
an edge-triggered pending bit for software vectored interrupts.  Additional detail
on this is described in the {nxti} section.

The value in the `clicintip[__i__]` is undefined when switching from
level-sensitive mode to edge-triggered mode in `clicintattr[__i__]`.

NOTE: Software cannot rely on the underlying `clicintip[__i__]`
register bits used in edge-triggered mode to hold state while in
level-sensitive mode.

=== CLIC Interrupt Enable (`clicintie`)
Each interrupt input has a dedicated interrupt-enable WARL bit (`clicintie[__i__]`)
This control bit is read-write to enable/disable the corresponding interrupt.
Software should assume clicintie[i]=0 means no interrupt enabled, and clicintie[i]=1 indicates an interrupt is enabled.

NOTE: `clicintie[__i__]` is the individual enable bit while {status}.{ie} is
the global enable bit for the current privilege mode. Therefore, for an
interrupt `_i_` to be enabled in the current privilege mode, both `clicintie[__i__]`
and {status}.{ie} have to be set.


NOTE: In contrast, since {status}.{ie} only takes effect in the current privilege
mode according to RISC-V convention, an interrupt `_i_` from a higher privilege mode
is enabled as long as `clicintie[__i__]` is set (regardless of the setting
of {status}.{ie} in the higher privilege modes).

NOTE: This register bit is defined as WARL as unimplemented interrupts appear hardwired to zero.

=== CLIC Interrupt Attribute (`clicintattr`)

This is an 8-bit WARL read-write register to specify various attributes for each interrupt.

NOTE: This register is defined as WARL as some implementations may want to hardwire to fixed values
only certain mode/trigger/shv types.

[source]
----
  clicintattr[i] register layout

  Bits    Field
  7:6     mode
  5:3     reserved (WPRI 0)
  2:1     trig
  0       reserved for smclicshv extension (WARL 0)
----

The 2-bit `trig` WARL field specifies the trigger type and polarity for each
interrupt input. Bit 1, `trig[0]`, is defined as "edge-triggered"
(0: level-triggered, 1: edge-triggered); while bit 2, `trig[1]`, is defined
as "negative-edge" (0: positive-edge, 1: negative-edge).
More specifically, there can be four possible combinations:
positive level-triggered, negative level-triggered, positive edge-triggered,
and negative edge-triggered.

The 2-bit `mode` WARL field specifies which privilege mode this interrupt
operates in as shown in the following table:

[source]
----
 Encoding for RISC-V privilege modes (mstatus.mpp)

 Mode Value   Name              Abbreviation
 0            User/Application  U
 1            Supervisor        S
 2            Reserved
 3            Machine           M

----

NOTE: For security purpose, the `mode` field can only be set to a privilege mode that is equal to or lower than the currently running privilege mode and if interrupts are supported at that privilege mode (e.g. ssclic extension).


=== CLIC Interrupt Input Control (`clicintctl`)

`clicintctl[__i__]` is an 8-bit WARL control register
to specify interrupt level and interrupt priority.

To select an interrupt to present to the core, the CLIC hardware
combines the valid bits in `clicintattr.mode` and
`clicintctl` to form an unsigned integer, then picks the global maximum
across all pending-and-enabled interrupts based on this value.
Next, the smclicconfig extension defines how to split
the `clicintctl` value into interrupt level and interrupt
priority. Finally, the interrupt level of this selected interrupt is
compared with the interrupt-level threshold of the associated privilege
mode to determine whether it is qualified or masked by the threshold
(and thus no interrupt is presented).


NOTE: Selecting an interrupt at a high privilege mode masks any
interrupt at a lower privilege mode since the higher-privilege mode
causes the interrupt signal to appear more urgent than any lower-privilege
mode interrupt.

NOTE: This register is defined as WARL as some implementations may want to support a limited number
of values in this register including hardwiring some bits to fixed values.

NOTE: Within a single privilege mode, it can be useful to separate interrupt
handler tasks from application tasks to increase robustness, reduce
space usage, and aid in system debugging.  Interrupt handler tasks
have non-zero interrupt levels, while application tasks have an
interrupt level of zero.

==== Interrupt Input Identification Number

The 4096 CLIC interrupt inputs are given unique identification numbers
with {cause} Exception Code (`exccode`) values.  When maintaining backward
compatibility is desired, the CLINT mode interrupts retain their original
cause values, while the new interrupts are numbered starting at 16.

NOTE: When upgrading from an earlier CLINT mode design
that had local interrupts attached directly to bits 16 and above, these
local interrupts can be now attached as CLIC inputs 16 and above to
retain the same interrupt IDs.


=== CLIC Interrupt Trigger (`clicinttrig`)

Optional interrupt triggers (`clicinttrig[__i__]`) are used to generate
a breakpoint exception, entry into Debug Mode, or a trace action.
If these registers are not implemented, they appear as hard-wired zeros.

NOTE: The notation [__i__] for the clicinttrig register in this section treats __i__ not an interrupt number
but is instead as a trigger number.

This logic is intended to be used with tmexttrigger.intctl as described in the RISC-V debug specification.

Each interrupt trigger is a 32-bit WARL register with the
following layout:

[source]
----
  clicinttrig register layout

  Bits    Field
  31      interrupt_trap_enable
  30      nxti_enable
  29:13   reserved (WARL 0)
  12:0    interrupt_number

----

The `interrupt_number` field selects which number of interrupt input
is used as the source for this interrupt trigger.

The `nxti_enable` control bit is read-write to enable/disable this
interrupt trigger when using accesses of {nxti} that include writes.  A trigger is signaled to the debug module if the interrupt code from a write access to {nxti} matches a `clicinttrig[__i__]`.interrupt_number and the associated `clicinttrig[__i__]`.nxti_enable is set.

The `interrupt_trap_enable` control bit is read-write to enable/disable this
interrupt trigger.  A trigger is signaled to the debug module if an interrupt trap is taken and the interrupt code matches a `clicinttrig[__i__]`.interrupt_number and the associated `clicinttrig[__i__]`.interrupt_trap_enable is set.

=== Indirect Access M-mode CSRs

Access to CLIC registers clicintctl[i], clicintattr[i], clicintip[i], clicintie[i], and clicinttrig[i]
utilizes the Indirect CSR Access extension (Smcsrind/Sscsrind). Implementations may support
another method to access these CSRs (e.g., via memory-mapped accesses) and any such a definition is outside the scope
of the CLIC specification.

If an interrupt _i_ is not present in the hardware, the corresponding
`clicintip[__i__]`, `clicintie[__i__]`, `clicintattr[__i__]`,
`clicintctl[__i__]` locations appear hardwired to zero.

All CLIC registers are visible to M-mode.

NOTE: Since accessing `clicintip[__i__]`, `clicintie[__i__]`, `clicintattr[__i__]`,
`clicintctl[__i__]` via indirect CSR access is not atomic, indirect CSR access of these registers while same privilege mode mstatus.xie is enabled requires mireg register state to be part of the interrupt handler's overall context state save/restore, although this is expected to be an atypical need for most interrupt handlers.

==== clicintctl[i] and clicintattr[i]

In this miselect offset range:

* Each mireg register controls the clic level/priority setting of four interrupts
* Each mireg2 register controls the clic attribute setting of four interrupts

[%autowidth]
|===
| miselect   |  mireg bits |  mireg state          |  mireg2 bits |  mireg2 state          | description

| 0x1000+i   |  7:0        | RW  clicintctl[i*4+0] |   7:0        | RW  clicintattr[i*4+0]   |  setting for interrupt i*4+0
| 0x1000+i   | 15:8        | RW  clicintctl[i*4+1] |  15:8        | RW  clicintattr[i*4+1] |  setting for interrupt i*4+1
| 0x1000+i   | 23:16       | RW  clicintctl[i*4+2] |  23:16       | RW  clicintattr[i*4+2] |  setting for interrupt i*4+2
| 0x1000+i   | 31:24       | RW  clicintctl[i*4+3] |  31:24       | RW  clicintattr[i*4+3] |  setting for interrupt i*4+3
|===

==== clicintip[i] and clicintie[i]

In this miselect offset range:

* Each mireg register controls the interrupt pending of thirty-two interrupts.
* Each mireg2 register controls the interrupt enable of thrity-two interrupts.

[%autowidth]
|===
| miselect   |  mireg bits |  mireg state          |  mireg2 bits |  mireg2 state          | description

| 0x1400    |   31:0   | RW clicintip[31:0]      |   31:0    | RW clicintie[31:0]       | settings for interrupts 31 through 0
| 0x1401    |   31:0   | RW clicintip[63:32]     |   31:0    | RW clicintie[63:32]      | settings for interrupts 63 through 32
6*^| ...
| 0x147F    |   31:0   | RW clicintip[4095:4064] |   31:0    | RW clicintie[4095:4064]  | settings for interrupts 4095 through 4064
|===

==== clicinttrig[i]

In this miselect offset range:

* Each mireg register controls an interrupt trigger register.

[%autowidth]
|===
| miselect   |  mireg bits |  mireg state          |  description

| 0x1480     |     31:0     |   RW   clicinttrig[0]  |  clic interrupt trigger 0
| 0x1480 + i |     31:0     |   RW   clicinttrig[i]  |  clic interrupt trigger i
4*^| ...
| 0x149F     |     31:0     |   RW   clicinttrig[31] |  clic interrupt trigger 31
|===


==== mcliccfg

[%autowidth]
|===
| miselect   |  mireg bits |  mireg state

| 0x14A0     |     31:0    |  reserved for mcliccfg in smclicconfig extension
|===
=== CLIC CSRs

This section describes the CLIC-related hart-specific Control and Status Registers (CSRs). When in
CLINT interrupt mode, the behavior is intended to be software
compatible with CLINT-mode-only systems.

Unless explicitly specified differently below, when not in CLIC mode, behavior of CLIC-only CSRs should be same as if CLIC was not implemented, so should be treated as a "reserved" operation. The value in the CSRs after switching from CLIC->CLINT->CLIC mode should be treated as "reserved" also, i.e., the value is undefined.

NOTE: It is recommended that implementations raise illegal instruction
exceptions when accessing a CSR that should not be visible in a given
interrupt mode.

The interrupt-handling CSRs are listed below, with changes and
additions for CLIC mode described in the following sections.

[source]
----
       Number  Name         Description
       0x300   mstatus      Status register
       0x303   mideleg      Interrupt delegation register (INACTIVE IN CLIC MODE)
       0x304   mie          Interrupt-enable register     (INACTIVE IN CLIC MODE)
       0x305   mtvec        Trap-handler base address / interrupt mode
 (NEW) 0x307   mtvt         Trap-handler vector table base address
       0x340   mscratch     Scratch register for trap handlers
       0x341   mepc         Exception program counter
       0x342   mcause       Cause of trap
       0x343   mtval        Bad address or instruction
       0x344   mip          Interrupt-pending register    (INACTIVE IN CLIC MODE)
 (NEW) 0x345   mnxti        Interrupt handler address and enable modifier
 (NEW) 0xFB1   mintstatus   Current interrupt levels
 (NEW) 0x347   mintthresh   Interrupt-level threshold
 (NEW) 0x348   mscratchcsw  Conditional scratch swap on priv mode change
 (NEW) 0x349   mscratchcswl Conditional scratch swap on level change

----

==== Changes to {status} CSRs

When in CLINT interrupt mode, the {status} register behavior is unchanged
(i.e., backwards-compatible with CLINT mode).  When in CLIC mode,
the {pp} and {pie} in {status} are now accessible
via fields in the {cause} register.

==== Changes to Delegation ({ideleg}) CSRs

In CLIC mode,
the `mode` field in Interrupt Attribute Register (`clicintattr[__i__].mode`)
specifies the privilege mode in which each interrupt should be taken.
If {ideleg} exists, the {ideleg} CSR ceases to have effect in CLIC mode.  If {ideleg} exists, the {ideleg}
CSR is still accessible and state bits retain their values when
switching between CLIC and CLINT interrupt modes.

==== Changes to {ie}/{ip} CSRs

The {ie} CSR appears hardwired to zero in CLIC mode, replaced by separate
interrupt enables (`clicintie[__i__]`).

The {ip} CSR appears hardwired to zero in CLIC mode, replaced by
separate interrupt pendings (`clicintip[__i__]`).

Writes to {ie}/{ip} will be ignored and will not trap (i.e., no access faults).
{ie}/{ip} always appear to be zero in CLIC mode.

In systems that support both CLINT and CLIC modes, the state bits in
{ie} and {ip} retain their value when switching between modes.

==== New {tvec} CSR Mode for CLIC

The CLIC interrupt-handling mode is encoded as a new state in the
existing {tvec} WARL register, where {tvec}.`mode` (the two
least-significant bits) is `11`, and bits {tvec}[5:2]
({tvec}.`submode`) are zero. The other encodings of {tvec}.`submode`
are reserved for future use.  The trap vector base address is
specified as the upper XLEN-6 bits of {tvec} (`base`) with six
lower zero bits appended, which constrains alignment on a 64-byte or
larger power-of-two boundary.

[source]
----
 CLIC mode xtvec register layout

  Bits          Field
  XLEN-1:6      base (WARL)
  5:2           submode (WARL)
  1:0           mode (WARL)
----

NOTE: Systems implementing both CLIC and CLINT mode may, but are not
required to, limit alignment of `mtvec` to 64-byte boundaries in both
modes.

NOTE: CLINT mode is defined as `mtvec.mode=00` or `mtvec.mode=01`.

When `mtvec.mode` is set to `11` and `mtvec.submode` is set to `0000`,
all privilege modes operate in CLIC mode.
In CLIC mode, {tvec}.`mode` and {tvec}.`submode` in lower
privilege modes are writeable but appear to be `11` and `0000`
respectively when read or implicitly read in that privilege mode.

If an implementation supports CLIC mode and any CLINT mode,
when `mtvec.mode` is set to a CLINT mode, all privilege modes operate
in CLINT mode.  In CLINT mode, both bits of {tvec}.`mode` are
writeable in lower-privilege modes but {tvec}.`mode` bit 1 appears to
be `0` when read or implicitly read in that privilege mode.  {tvec} operates as
before where each privilege mode can set their CLINT mode (direct or
vectored) independently.

NOTE: Although future CLIC versions may allow privileges to have
different {tvec}.`mode` settings, for now all privilege modes must run
in either CLIC mode or all privilege modes must run in non-CLIC mode.
These constraints might change if there are future additions to the
CLIC or other new interrupt controller specs.

[source]
----
 mode submode PC on interrupt
 ==== ======= ============================================
 00   xxxx    OBASE              # CLINT direct mode
 01   xxxx    OBASE+4*exccode    # CLINT vectored mode
 11   0000    NBASE              # CLIC mode
 10   0000    Reserved
 1x   yyyy    Reserved

where:
  OBASE = xtvec[XLEN-1:2]<<2   # CLINT mode vector base is at least 4-byte aligned
  NBASE = xtvec[XLEN-1:6]<<6   # CLIC mode vector base is at least 64-byte aligned
  x     = any value (don't care)
  yyyy  = any non-zero value
----

Implementations might support only one of CLINT or CLIC mode.
If only basic mode is supported, writes to bit 1 are ignored and it is
always set to zero (current behavior).  If only CLIC mode is supported,
writes to bit 1 are also ignored and it is always set to one.  CLIC
mode hardwires {tvec} bits 2-5 to zero (assuming no further CLIC
extensions are supported).

In CLIC mode, synchronous exception traps always jump to NBASE.

==== New {tvt} CSRs

The {tvt} WARL XLEN-bit CSR holds the base address of the trap vector
table, aligned on a 64-byte or greater power-of-two boundary. The actual
alignment can be determined by writing ones to the low-order bits then reading
them back. Values other than 0 in the low 6 bits of {tvt} are reserved.

The value of the {tvt} CSR is used when the {nxti} CSR is read.
The value of {tvt} CSR is also used when the smclicshv exception is present
and clicintrattr[i].shv = 1 (hardware vectored interrupt).

==== Changes to {cause} CSRs

In both CLINT and CLIC modes, the {cause} CSR is written at the
time an interrupt or synchronous trap is taken, recording the reason for
the interrupt or trap.  For CLIC mode, {cause} is also extended to record
more information about the interrupted context, which is used to
reduce the overhead to save and restore that context for an {ret}
instruction. CLIC mode {cause} also adds state to record progress
through the trap handling process.

[source]
----
 mcause
 Bits   Field         Description
 XLEN-1 Interrupt     Set to 1 for interrupts and 0 for exceptions
 30     (reserved)    Contains minhv (AKA xinhv) bit when smclicshv extension present
 29:28  mpp[1:0]      Previous privilege mode, usually same as mstatus.mpp
 27     mpie          Previous interrupt enable, usually same as mstatus.mpie
 26:24  (reserved)
 23:16  mpil[7:0]     Previous interrupt level
 15:12  (reserved)
 11:0   exccode[11:0] Exception/interrupt code
----

The `mcause.mpp` and `mcause.mpie` fields typically mirror the `mstatus.mpp` and
`mstatus.mpie` fields, and are aliased into `mcause` to reduce context
save/restore code. For backwards compatibility in implementations supporting both CLINT and CLIC modes, when
switching to CLINT mode the new CLIC {cause} state field
({pil}) is zeroed.  The other new CLIC {cause} fields,
{pp} and {pie}, appear as zero in the {cause} CSR but the corresponding
state bits in the `mstatus` register are not cleared.

If the hart is currently running at some privilege mode (`pp`) at some
interrupt level (`pil`) and an enabled interrupt becomes pending at
any interrupt level in a higher privilege mode or if an interrupt assigned to a
higher interrupt level in the current privilege mode becomes pending
and interrupts are globally enabled in this privilege mode, then
execution is immediately transferred to a handler running with the new
interrupt's privilege mode (`**__x__**`) and interrupt level (`il`).

As stated in the RISC-V privilege specification,
when a trap is taken from privilege mode y into privilege mode x,
xPIE is set to the value of xIE; xIE is set to 0; and
xPP is set to y.  xepc is written with the virtual address of the instruction
that was interrupted or that encountered the exception.
Additionally in CLIC mode, interrupt level (`xpil`) is set to xintstatus.xil and
xcause.exccode is written with a code indicating the event (the id of the
interrupt or exception code) that caused the trap.

Note: For now all privilege modes must run in either CLIC mode or all
privilege modes must run in non-CLIC mode so switching to CLINT mode
from CLIC mode causes {pil} in all privilege modes to be zeroed.

When not in CLIC mode, {cause} has the CLINT mode format.

==== Next Interrupt Handler Address and Interrupt-Enable CSRs ({nxti})

The {nxti} CSR is used by software to improve the performance of handling back-to-back
software vectored interrupts.  It does this by avoiding the overhead of additional interrupt pipeline
flushes and redundant context save/restore for these back-to-back software vectored interrupts.
The {nxti} CSR is intended to be used inside an interrupt handler
after an initial interrupt has been taken and {cause} and {epc}
registers have been updated with the interrupted context and the id of the interrupt.

NOTE: The {nxti} CSR is unusual in that there is actually no physical {nxti} CSR
and accesses to it actually access hart state in other CSRs.

The value returned by a CSR read of {nxti} is the non-zero address of a vector
table entry if there is a suitable pending interrupt and the hart is in CLIC mode.
Otherwise zero is returned.
For a pending interrupt to be considered "suitable", all the following must be true about the interrupt:

* Must be a software vectored interrupt
* Must be a horizontal interrupt
* Must have a level greater than the saved interrupt level (held in {cause}.pil)
* Must have a level greater than the interrupt threshold (held in {intthresh}) of the corresponding privilege mode

NOTE: Hardware vectored and software vectored interrupts may have different software interfaces.
The assumption is that hardware vectoring would have customized context save/restore finishing with {ret},
whereas software vectoring would use a generic context save/restore and return with a ret instruction.
To support these software interface differences, reads when the highest ranked interrupt is a hardware vectored interrupt return 0.

If the CSR instruction that accesses {nxti} includes a write, the
{status} CSR is used for the read-modify-write portion of the
operation, while the {cause} register's `exccode` field and the
{intstatus} register's {il} field can also be updated with the new interrupt id and level.
If the interrupt is edge-triggered, then the pending bit is also zeroed.

The {nxti} CSR may only be accessed with the CSRR (CSRRS rd,csr,x0), CSRRSI/CSRRS, or CSRRCI instructions.
Accessing the {nxti} CSR using any other CSR instruction (i.e., CSRRW, CSRRC, or CSRRWI) is reserved.
Also, accessing {nxti} with CSRRSI with non-zero immediate values for bits 0, 2, and 4 is reserved.

NOTE: Following the usual convention for CSR instructions, if the CSR
instruction does not include write side effects (e.g., `csrr t0, {nxti}`),
then no state update on any CSR occurs.  This can be used to
determine if an interrupt could be taken without actually updating
{il} and `exccode`.

NOTE: Vertical interrupts to higher privilege modes will be taken
preemptively by the hardware, so {nxti} effectively only ever handles
the next interrupt in the same privilege mode.


Pseudo-code for csrrsi rd, mnxti, uimm[4:0] in M mode:
[source]
----
 // clic.priv, clic.level, clic.id represent the highest-ranked
 // interrupt currently present in the CLIC
 mstatus |= uimm[4:0]; // Performed regardless of interrupt readiness.
 if (clic.priv==M && clic.level > mcause.pil && clic.level > mintthresh.th) {
   // There is an available interrupt.
   if (uimm[4:0] != 0) {  // Side-effects should occur.
     // Commit to servicing the available interrupt.
     mintstatus.mil = clic.level; // Update hart's interrupt level.
     mcause.exccode = clic.id;   // Update interrupt id in mcause.
     mcause.interrupt = 1;       // Set interrupt bit in mcause.
     if (clicintattr[clic.id][1] == 1) { // If edge interrupt,
       clicintip[clic.id] = 0;           // clear edge interrupt
     }
   }
   rd = VTBASE + XLEN/8 * clic.id; // Return pointer to trap handler entry.
 } else {
   // No interrupt or in non-CLIC mode.
   rd = 0;
 }
 // When a different CSR instruction is used, the update of mstatus and the test
 // for whether side-effects should occur are modified accordingly.
 // When a different privileges xnxti CSR is accessed then clic.priv is compared with
 // the corresponding privilege and xstatus, xintstatus.xil, xcause.exccode are the
 // corresponding privileges CSRs.
----

Pseudo-code for csrrs rd, mnxti, rs1 in M mode:
[source]
----
 // clic.priv, clic.level, clic.id represent the highest-ranked interrupt currently present in the CLIC
   if (rs1 != x0)
   {
      mstatus |= rs1[4:0]; // Performed regardless of interrupt readiness.
   }
   if (clic.priv==M && clic.level > rs1[23:16] && clic.level > mintthresh.th) {
     // There is an available interrupt.
     if (rs1[4:0] != 0 && rs1 != x0) {  // Side-effects should occur.
       // Commit to servicing the available interrupt.
       mintstatus.mil = clic.level; // Update hart's interrupt level.
       mcause.exccode = clic.id;   // Update interrupt id in mcause.
       mcause.interrupt = 1;       // Set interrupt bit in mcause.
       if (clicintattr[clic.id][1] == 1) { // If edge interrupt,
         clicintip[clic.id] = 0;           // clear edge interrupt
       }
     }
     rd = VTBASE + XLEN/8 * clic.id; // Return pointer to trap handler entry.
   } else {
     // No interrupt or in non-CLIC mode.
     rd = 0;
   }

 // When a different CSR instruction is used, the update of mstatus and the test
 // for whether side-effects should occur are modified accordingly.
 // When a different privileges xnxti CSR is accessed then clic.priv is compared with
 // the corresponding privilege and xstatus, xintstatus.xil, xcause.exccode are the
 // corresponding privileges CSRs.
----

==== New Interrupt Status ({intstatus}) CSRs

A new M-mode CSR, `mintstatus`, holds the active interrupt level for
each supported privilege mode.  These fields are read-only.  The
primary reason to expose these fields is to support debug.

[source]
----
mintstatus fields
 bits    description
 31:24   mil
 23:16   (reserved)
 15: 8   sil if ssclic is supported
  7: 0   (reserved)
----

The {intstatus} registers are accessible in CLINT mode for harts that
support both CLINT and CLIC modes.

==== New Interrupt-Level Threshold ({intthresh}) CSRs

The interrupt-level threshold ({intthresh}) is a new read-write WARL CSR,
which holds an 8-bit field (`th`) for the threshold level of the
associated privilege mode.  The `th` field is held in the least-significant
8 bits of the CSR, and zero should be written to the upper bits.

A typical usage of the interrupt-level threshold is for implementing
critical sections. The current handler can temporarily raise its effective
interrupt level to implement a critical section among a subset of levels,
while still allowing higher interrupt levels to preempt.

The current hart's effective interrupt level would then be:
    effective_level = max({intstatus}.{il}, {intthresh}.`th`)

The max is used to prevent a hart from dropping below its original level
which would break assumptions in design, and also makes it
simple for software to remove threshold without knowing its own level
by simply setting {intthresh} to the lowest supported {intthresh} value.

The interrupt-level threshold is only valid when running in associated
privilege mode and not in other modes. This is because interrupts for
lower privilege modes are always disabled, whereas interrupts for higher
privilege modes are always enabled.

If the hart is currently running at some privilege mode `x`, an MRET
or SRET instruction that changes the privilege mode to a mode less
privileged than `x` also sets {intthresh} to the lowest supported {intthresh} value.
This helps software avoid a higher privilege mode from having a non-minimum threshold while a lower
privilege mode is running.

NOTE: The anticipated use of threshold is to provide critical sections
within code running at one privilege mode, not to selectively mask
interrupts before running lower-privilege code.  If desired,
higher-privilege-mode interrupts can be selectively disabled using
local interrupt enables before switching to a lower privilege mode.

NOTE: This behavior significantly reduces the hardware cost because it
only needs to select one global maximum interrupt and compare with the
threshold of the associated privilege mode.  If higher-privilege modes
could have non-minimum thresholds, hardware would have to select multiple
maximum interrupts (one for the current mode and one for each
higher-privilege mode) qualified by the per-mode threshold, then pick
a qualified maximum interrupt with the highest privilege mode.

==== Scratch Swap CSR ({scratchcsw}) for Multiple Privilege Modes

To accelerate interrupt handling with multiple privilege modes, a new
CSR {scratchcsw} is defined for all but the lowest privilege mode supported in a given implementation
to support conditional swapping of the {scratch} register when
transitioning between privilege modes.  The CSR instruction is used
once at the entry to a handler routine and once at handler exit, so
only adds two instructions to the interrupt code path.

These CSRs are only designed to be used with the `csrrw` instruction
with neither `rd` nor `rs1` set to `x0`.  Accessing the {scratchcsw}
register with the `csrrw` instruction with either `rd` or `rs1` set to
`x0`, or using any other CSR instruction form
(CSRRWI/CSRRS/CSRRC/CSRRSI/CSRRCI), is reserved.

When using `csrrw` to access {scratchcsw}, the value written into `rd`
is either {scratch} if {pp} is different than the current privilege
mode, or `rs1` if {pp} is the same as the current privilege mode.  The
{scratch} register is only written with the original value of `rs1` if
there is a privilege mode difference.

NOTE: This is different than a regular CSR instruction as the value
returned is different from the value used in the read-modify-write
operation.

NOTE: The CSR instructions are defined to always copy a result
({scratch} or `rs1`) to the `rd` destination to simplify
implementations using register renaming, and in normal use the
instructions set both `rs1` = `sp` and `rd` = `sp`.

An example of normal usage of the {scratchcsw} CSR is as follows:

[source]
----
csrrw sp, mscratchcsw, sp
# If mpp!=M-mode, swap mscratch and stack pointer (sp)
# otherwise sp copied to sp (i.e., no change) and mscratch unchanged
----

Formal description follows:

[source]
----
csrrw rd, mscratchcsw, rs1

match cur_privilege {
  Machine => match mstatus.MPP() {
    Machine => rd = rs1; // mscratch unchanged.
    _       => t = rs1; rd = mscratch; mscratch = t; /* default: for all other priv modes*/
  }
}
----

NOTE: To avoid virtualization holes, software cannot directly read the
hart's current privilege mode. Also, an instruction attempting to access
a given mode's {scratchcsw} CSR from a lesser-privileged mode will trap
to avoid a virtualization hole.

==== Scratch Swap CSR ({scratchcswl}) for Interrupt Levels

A new {scratchcswl} CSR is added to support faster swapping of the
stack pointer between interrupt and non-interrupt code running in the
same privilege mode.

[source]
----
csrrw rd, mscratchcswl, rs1

// Pseudocode operation.
if ( (mcause.pil==0) != (mintstatus.mil==0) ) then {
    t = rs1; rd = mscratch; mscratch = t;
} else {
    rd = rs1; // mscratch unchanged.
}

// Usual use: csrrw sp, mscratchcswl, sp
----

This new CSR operates similarly to {scratchcsw} except that the swap
condition is true when the interrupter and interruptee are not both
application tasks or not both interrupt handlers.

As with {scratchcsw}, these CSRs are only designed to be used with the csrrw instruction with neither rd nor rs1 set to x0. Accessing the {scratchcswl} register with the csrrw instruction with either rd or rs1 set to x0, or using any other CSR instruction (CSRRWI/CSRRS/CSRRC/CSRRSI/CSRRCI), is reserved.


=== CLIC Reset Behavior

In general in RISC-V, mandatory reset state is minimized but platform
specifications or company policy might add additional reset
requirements.  Since the general privileged architecture states that
mstatus.mie is reset to zero, interrupts will not be enabled coming
out of reset.

==== CLIC mandatory reset state

{intstatus}.{il} and {cause}.{pil} fields reset to 0.  Interrupt level 0 corresponds to regular
execution outside of an interrupt handler.

The reset behavior of other fields is platform-specific.

=== CLIC Interrupt Operation

This section describes the operation of CLIC interrupts.

==== General Interrupt Overview

At any time, a hart is running in some privilege mode with some
interrupt level.  The hart's privilege mode is held internally but is not visible to software running on a hart (to avoid
virtualization holes), but the current interrupt level is made visible
in the {intstatus} register.

Within a privilege mode `*_x_*`, if the associated global
interrupt-enable {ie} is clear, then no interrupts will be taken in
that privilege mode, but a pending-enabled interrupt in a higher
privilege mode will preempt current execution.  If {ie} is set, then
pending-enabled interrupts at a higher interrupt level in the same
privilege mode will preempt current execution and run the interrupt
handler for the higher interrupt level.

As with the existing RISC-V mechanism, when an interrupt or
synchronous exception is taken, the privilege mode and interrupt level
are modified to reflect the new privilege mode and interrupt level.
The global interrupt-enable bit of the handler's privilege mode is
cleared, to prevent preemption by higher-level interrupts in the same
privilege mode.

The overall behavior is summarized in the following table: the Current
`p/ie/il` fields represent the current privilege mode `P` (not
software visible), interrupt enable `ie` =
({status}.{ie} & `clicintie[__i__]`)  and interrupt
level `L` = max({intstatus}.{il}, {intthresh}.`th`);
the CLIC `priv`,`level`, and `id` fields
represent the highest-ranked interrupt currently present in the CLIC
with `nP` representing the new privilege mode, `nL` representing the
new interrupt level, and `id` representing the interrupt's id;
Current' shows the `p/ie/il` context in the handler's privilege mode;
`pc` represents the program counter with `V` representing the result
of any hardware vectoring; `cde` represents the {cause} `exccode`
field; while the Previous `pp/il/ie/epc` columns represent previous
context fields in {cause} and {epc}.

[%autofit]
----
 Current  |      CLIC          |->      Current'          Previous
 p/ie/il  | priv level   id    |->    p/ie/il  pc  cde   pp/il/ie epc
 P  ?  ?  | nP<P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  0  ?  | nP=P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupts disabled
 P  1  ?  | nP=P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  1  L  | nP=P   0<nL<=L  ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  1  L  | nP=P   L<nL    id  |->    P 0  nL  V   id    P  L  1  pc  # Horizontal interrupt taken
 P  ?  ?  | nP>P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  e  L  | nP>P   0<nL    id  |->   nP 0  nL  V   id    P  L  e  pc  # Vertical interrupt taken
----

==== Critical Sections in Interrupt Handlers

To implement a critical section between interrupt handlers at
different levels in the same privilege mode, an interrupt handler at
any interrupt level can temporarily raise the interrupt-level threshold
(`mintthresh.th`) to mask a subset of levels,
while still allowing higher interrupt levels to preempt.
Alternatively, although not recommended due to worse system impacts, it can
clear the mode's global interrupt-enable bit
({ie}) to prevent any interrupts with the same privilege mode from
being taken.

==== CLIC events that cause the hart to resume execution after Wait for Interrupt (WFI) Instruction
As described in the privileged specification, the Wait for Interrupt instruction (WFI) provides a hint to the implementation that the current hart can be stalled.  The hart may optionally resume execution anytime.  This section describes CLIC events that must cause the hart to resume execution.

NOTE: WFI can be a NOP and not actually pause hart execution. In addition,
implementations can resume execution after a WFI for any other reason.

As in the privileged specification, if an interrupt is taken while the hart is stalled, the interrupt
trap will be taken on the following instruction, i.e., execution resumes in the trap handler and mepc
= pc + 4.  If the event that causes the hart to resume execution does not cause an interrupt to be taken,
execution will resume at pc + 4.

In CLIC mode, similar to CLINT mode, events causing the hart to resume execution after a Wait for Interrupt instruction (WFI) are
unaffected by the global interrupt-enable bits in {status}.{ie} but should
honor `clicintie[__i__]` and {intthresh}.

.A pending-and-enabled interrupt _i_ causes the hart to resume execution if interrupt _i_
* has a higher privilege mode than the current privilege mode and
* the interrupt priority reduction tree selects interrupt _i_ as the maximum across all pending-and-enabled interrupts and
* the interrupt _i_ level is not equal to 0.

.A pending-and-enabled interrupt _i_ causes the hart to resume execution if interrupt _i_
* has the same privilege mode as the current privilege mode and
* the interrupt priority reduction tree selects interrupt _i_ as the maximum across all pending-and-enabled interrupts and
* the interrupt _i_ level is greater than max({intstatus}.{il}, {intthresh}.`th` )

.A pending-and-enabled interrupt _i_ causes the hart to resume execution if interrupt _i_
* has a lower privilege mode than the current privilege mode and
* the interrupt priority reduction tree selects interrupt _i_ as the maximum across all pending-and-enabled interrupts and
* the interrupt _i_ level is not equal to 0.

NOTE: If an implementation allows setting an interrupts level to 0,  level 0 will behave as a locally disabled interrupt but can still mask lower-mode interrupts.  For example, if there is a non-zero level supervisor interrupt pending and a level-zero machine interrupt pending, the machine interrupt will be the global maximum across all pending-and-enabled interrupts but interrupt level 0 implies no interrupt. So programming an interrupt level to 0 should not be used to disable interrupts.  `clicintie[__i__]` should be used instead.

NOTE: {intthresh} only applies to the current privilege mode.  There is a proposal to add a new WFMI instruction ("wait for mode's interrupts") to the privilege specification. This instruction only has to wakeup for pending-and-enabled interrupts in the current mode, and is not required to wakeup for pending-and-enabled interrupts in lower privilege modes. Pending-enabled higher privilege-mode interrupts will interrupt/wakeup as usual.

==== Synchronous Exception Handling

Horizontal synchronous exception traps, which stay within a privilege
mode, are serviced with the same interrupt level as the instruction
that raised the exception.

Vertical synchronous exception traps, which are serviced at a higher
privilege mode, are taken at interrupt level 0 in the higher privilege
mode.

WARNING: Traps should be avoided at any time when {epc}/{cause} are live
because these CSRs will be overwritten. Software should try to back them
up if needed.

==== Non-Resumable Non-Maskable Interrupts

The handling of NMIs is implementation-specific, but NMIs are always
handled in M-mode and can overwrite `mepc` and `mcause` of an active
M-mode CLIC interrupt handler.

==== Resumable Non-Maskable Interrupts

NOTE: This section describes the interaction of the CLIC with the
proposed new RNMI specification.

The resumable NMI (RNMI) extension adds additional `mnepc`, `mncause`,
and `mnstatus` CSRs.  The RNMI CSRs are separate from the CLIC CSRs and so CLIC state does not need to be saved in RNMI CSRs.
This makes the design of the RNMI extension orthogonal to the hart's general interrupt scheme.

==== Returns from Handlers

As stated in the RISC-V Privilege Specification,
when executing an xRET instruction, supposing xPP holds the value y, xIE is set to xPIE; the
privilege mode is changed to y; xPIE is set to 1; and xPP is set to the least-privileged supported
mode.  xRET sets the pc to the value stored in the xepc register.
Additionally in CLIC mode, xRET sets xintstatus.xil to xcause.xpil.
The {ret} instruction does not modify the {cause}.{pil} field in {cause}.

== ssclic S-mode CLIC extension
The ssclic extension depends on the smclic extension.

=== Indirect Access S-mode CSRs

If an interrupt _i_ is not present in the hardware, the corresponding
`clicintip[__i__]`, `clicintie[__i__]`, `clicintattr[__i__]`,
`clicintctl[__i__]` locations appear hardwired to zero.

In S-mode, any interrupt _i_ that is not accessible to S-mode appears as
hard-wired zeros in `clicintip[__i__]`, `clicintie[__i__]`, `clicintattr[__i__]`, and
`clicintctl[__i__]`.

==== clicintctl[i] and clicintattr[i]

In this siselect offset range:

* Each sireg register controls the clic level/priority setting of four interrupts
* Each sireg2 register controls the clic attribute setting of four interrupts

[%autowidth]
|===
| siselect   |  sireg bits |  sireg state          |  sireg2 bits |  sireg2 state          | description

| 0x1000+i   |  7:0        | RW  clicintctl[i*4+0] |   7:0        | RW  clicintattr[i*4+0]   |  setting for interrupt i*4+0
| 0x1000+i   | 15:8        | RW  clicintctl[i*4+1] |  15:8        | RW  clicintattr[i*4+1] |  setting for interrupt i*4+1
| 0x1000+i   | 23:16       | RW  clicintctl[i*4+2] |  23:16       | RW  clicintattr[i*4+2] |  setting for interrupt i*4+2
| 0x1000+i   | 31:24       | RW  clicintctl[i*4+3] |  31:24       | RW  clicintattr[i*4+3] |  setting for interrupt i*4+3
|===

==== clicintip[i] and clicintie[i]

In this siselect offset range:

* Each sireg register controls the interrupt pending of thirty-two interrupts.
* Each sireg2 register controls the interrupt enable of thrity-two interrupts.

[%autowidth]
|===
| siselect   |  sireg bits |  sireg state          |  sireg2 bits |  sireg2 state          | description

| 0x1400    |   31:0   | RW clicintip[31:0]      |   31:0    | RW clicintie[31:0]       | settings for interrupts 31 through 0
| 0x1401    |   31:0   | RW clicintip[63:32]     |   31:0    | RW clicintie[63:32]      | settings for interrupts 63 through 32
6*^| ...
| 0x147F    |   31:0   | RW clicintip[4095:4064] |   31:0    | RW clicintie[4095:4064]  | settings for interrupts 4095 through 4064
|===

==== clicinttrig[i]

In this siselect offset range:

* Each sireg register controls an interrupt trigger register.

[%autowidth]
|===
| siselect   |  sireg bits |  sireg state          |  description

| 0x1480     |     31:0     |   RW   clicinttrig[0]  |  clic interrupt trigger 0
| 0x1480 + i |     31:0     |   RW   clicinttrig[i]  |  clic interrupt trigger i
4*^| ...
| 0x149F     |     31:0     |   RW   clicinttrig[31] |  clic interrupt trigger 31
|===


==== scliccfg

[%autowidth]
|===
| siselect   |  sireg bits |  sireg state

| 0x14A0     |     31:0    |  reserved for scliccfg in smclicconfig extension
|===
=== ssclic CLIC CSRs
The interrupt-handling CSRs are listed below, with changes and
additions for CLIC mode described in the following sections.

[source]
----
       Number  Name         Description
       0x100   sstatus      Status register
       0x104   sie          Interrupt-enable register     (INACTIVE IN CLIC MODE)
       0x105   stvec        Trap-handler base address / interrupt mode
 (NEW) 0x107   stvt         Trap-handler vector table base address
       0x140   sscratch     Scratch register for trap handlers
       0x141   sepc         Exception program counter
       0x142   scause       Cause of trap
       0x143   stval        Bad address or instruction
       0x144   sip          Interrupt-pending register    (INACTIVE IN CLIC MODE)
 (NEW) 0x145   snxti        Interrupt handler address and enable modifier
 (NEW) 0xDB1   sintstatus   Current interrupt levels
 (NEW) 0x147   sintthresh   Interrupt-level threshold
 (NEW) 0x148   sscratchcsw  Conditional scratch swap on priv mode change
 (NEW) 0x149   sscratchcswl Conditional scratch swap on level change

----

==== State Enable

If the Smstateen extension is implemented, then the bit 53 (CLIC) in mstateen0 is
implemented. If bit 53 (CLIC) of a controlling mstateen0 CSR is zero, then
access to the new CSRs (stvt, snxti, sintstatus, sintthresh,
sscratchcsw, sscratchcswl) by S-mode or a lower privilege mode
results in an illegal instruction exception, except if the hypervisor
extension is implemented and the conditions for a virtual instruction
exception apply, in which case a virtual instruction exception is
raised when in VS or VU mode instead of an illegal instruction
exception.

==== ssclic Changes to {cause} CSRs

[source]
----
scause
 Bits    Field        Description
 XLEN-1 Interrupt     Interrupt=1, Exception=0
    30  (reserved for smclicshv extension)
    29  (reserved)
    28  spp           Previous privilege mode, same as sstatus.spp
    27  spie          Previous interrupt enable, same as sstatus.spie
 26:24  (reserved)
 23:16  spil[7:0]     Previous interrupt level
 15:12  (reserved)
 11:0   exccode[11:0] Exception/interrupt code
----

The supervisor `scause` register has only a single `spp` bit (to
indicate user/supervisor) mirrored from `sstatus.spp`

==== ssclic New Interrupt Status ({intstatus}) CSRs

A corresponding supervisor mode, `sintstatus` CSR
provides restricted views of mintstatus.

[source]
----
sintstatus fields
 31:16 (reserved)
 15: 8 sil
  7: 0 uil if usclic is supported
----

==== ssclic Scratch Swap CSR ({scratchcsw}) for Multiple Privilege Modes

[source]
----
csrrw rd, sscratchcsw, rs1

match cur_privilege {
  Supervisor => if sstatus.SPP() then {
                  rd = rs1; // sscratch unchanged.
                } else {
                  t = rs1; rd = sscratch; sscratch = t;
                }
/* Although machine-mode access to sscratchcsw is not expected to be the normal usage, */
/* it is specified in a way that simplifies hardware. */
  Machine    => match mstatus.MPP() {
               Supervisor => t  = rs1; rd = sscratch; sscratch = t;
               Machine    => rd = rs1; // sscratch unchanged.
               _          => t  = rs1; rd = sscratch; sscratch = t; /* default */
             }
}
----

=== ssclic CLIC Reset Behavior

NOTE: For an S-mode execution environment, the EEI should specify
that status.sie is also reset on entry. It is then responsibility of
the execution environment to ensure that is true before beginning execution
in S-mode.

== smclicshv CLIC selective hardware vectoring extension

The selective hardware vectoring extension adds the ability for each interrupt
to be configured to use hardware vectoring or software vectoring.
Interrupts are always software vectored if smclicshv isn't supported when in CLIC mode.
When a hardware vectored interrupt is taken, the hart hardware loads the vector
table entry for the associated interrupt (table pointed to {tvt} CSR),
masks off the least-significant bit (for IALIGN=16) or masks of the 2 least-significant bits (for IALIGN=32),
and then jumps to the masked address.
The masked vector table entry bit(s) are reserved and should be zero.
When a software vectored interrupt is taken, the hart jumps to the address in the {tvec} CSR and then
it is software's responsibility to load the vector table entry for the associated interrupt
and jump to the address in that entry.

Hardware vectoring has the advantage of lower interrupt latency at the price of a slight
increase in code size because each hardware vectored interrupt has its own code to perform context save/restore.
Software vectoring has the advantage of smaller code size by sharing code to perform context save/restore
at the price of slightly higher interrupt latency. Software vectoring supports interrupt chaining
via the {nxti} CSR but interrupt chaining is not currently supported by hardware vectoring.

=== smclicshv Changes to CLIC Registers

==== smclicshv Changes to CLIC Interrupt Pending (`clicintip`)

When the input is configured for edge-sensitive input,
hardware clears the associated interrupt pending bit when a
hardware vectored interrupt is serviced.
See additional details on hardware clearing in the {tvec} section.

NOTE: To improve performance, when a hardware vectored interrupt is selected
and serviced, the hardware automatically clears its corresponding
edge-triggered pending bit, so software doesn't need to clear the
pending bit in the service routine.

In contrast, when a software vectored interrupt is selected,
the hardware will not automatically clear an edge-triggered pending
bit. Harware will clear an edge-triggered pending bit upon execution
of the appropriate access to the {nxti} CSR (see that CSR's description for details).

==== smclicshv Changes to CLIC Interrupt Attribute (`clicintattr`)

This is an 8-bit WARL read-write register to specify various attributes for each interrupt.

[source]
----
  clicintattr register layout

  Bits    Field
  7:6     mode
  5:3     reserved (WPRI 0)
  2:1     trig
  0       shv
----

The 1-bit `shv` field is used for Selective Hardware Vectoring.
If `shv` is 0, it assigns this interrupt to be software vectored and thus it jumps
to the common code at {tvec}.
If `shv` is 1, it assigns this interrupt to be hardware vectored and thus it
automatically jumps to the trap-handler function pointer specified in {tvt} CSR.
This feature allows some interrupts to all jump to a common base address held
in {tvec}, while the others are vectored in hardware via a table pointed to
by the additional {tvt} CSR.

=== smclicshv Changes to CLIC CSRs
==== smclicshv Changes to {tvec} CSR Mode for CLIC

[source]
----
 mode submode PC on Interrupt
 00   xxxx    OBASE                                             # CLINT direct mode
 01   xxxx    OBASE+4*exccode                                   # CLINT vectored mode
 11   0000    shv ? (M[VTBASE+XLEN/8*exccode)] & MASK) : NBASE  # CLIC mode
 10   0000    Reserved
 1x   yyyy    Reserved

where:
  OBASE  = xtvec[XLEN-1:2]<<2   # CLINT mode vector base is at least 4-byte aligned
  NBASE  = xtvec[XLEN-1:6]<<6   # CLIC mode vector base is at least 64-byte aligned
  VTBASE = xtvt[XLEN-1:6]<<6    # Vector table base is at least 64-byte aligned
  shv    = clicintrattr[i].shv
  x      = any value (don't care)
  yyyy   = any non-zero value
  M[a]   = Contents of memory address at address "a"
  MASK   = ~0x1 if IALIGN=16 or ~0x3 if IALIGN=32
----

In CLIC mode, writing `0` to `clicintattr[__i__].shv`
sets interrupt `i` to software vectored,
where the hart jumps to the
trap handler address held in the upper XLEN-6 bits of
{tvec} for all exceptions and interrupts in privilege mode
`**__x__**`.

On the other hand, writing `1` to `clicintattr[__i__].shv`
sets interrupt `i` to hardware vectored. When these interrupts are taken, the hart
switches to the handler's privilege mode, and performs the trap side effects described in this and the privileged specification (e.g. update {intstatus}, {cause}, {status} fields including clearing {status}.{ie}).
At this time, if the associated interrupt pending bit is configured for edge-sensitive input, it is cleared by hardware. The hart then fetches an XLEN-bit handler
address with permissions corresponding to the handler's mode from the in-memory table whose base address (VTBASE) is in
{tvt}.  The trap handler function address is fetched from
`VTBASE+XLEN/8*exccode`.  If the fetch is successful, the hart
clears the low bit of the handler address and sets the PC to this handler
address.
If the trap handler function address fetch is unsuccessful and a exception trap occurs,
the {inhv} bit in {cause} of the exception handler privilege mode is set indicating that {epc} of
the exception handler privilege mode contains a trap handler function address instead of the virtual address of an instruction.

The overall effect is:

     pc := M[VTBASE + XLEN/8 * exccode] & MASK

[source]
----
           # Vector table layout for RV32 (4-byte function pointers)
  mtvt ->  0x800000 # Interrupt 0 handler function pointer
           0x800004 # Interrupt 1 handler function pointer
           0x800008 # Interrupt 2 handler function pointer
           0x80000c # Interrupt 3 handler function pointer

           # Vector table layout for RV64 (8-byte function pointers)
  mtvt ->  0x800000 # Interrupt 0 handler function pointer
           0x800008 # Interrupt 1 handler function pointer
           0x800010 # Interrupt 2 handler function pointer
           0x800018 # Interrupt 3 handler function pointer
----

NOTE: The CLINT vectored mode simply jumps to an address in
the trap vector table, while the CLIC hardware vectored mode reads a
handler function address from the table, and jumps to it in hardware.

NOTE: The vector table contains vector addresses rather than
instructions because it simplifies static initialization in C.
More specifically, the entries in the table are simple XLEN-bit
function pointers.

NOTE: The hardware vectoring bit {inhv} is provided to allow resumable
traps on fetches to the vector table.

When a trap is taken, the {inhv} bit is set by hardware to indicate if {epc} is the address of a table entry
or cleared by hardware to indicate if {epc} is the address of an instruction.
The {inhv} bit is only set by hardware if an exception occurs during the table vector
read operation.  The {inhv} bit can be written by software, including
when hardware vectoring is not in effect. The {inhv} bit has no effect
except when returning using an {ret} instruction.

When returning from an {ret} instruction, the {inhv} bit modifies behavior
as follows:

If the {inhv} bit is set, the hart
resumes the trap handler memory access to retrieve the function
pointer for vectoring with permissions corresponding to the previous
privilege mode.
The trap handler function address is obtained from the current
privilege mode's `xepc` with the low bits of the address cleared to
force the access to be naturally aligned to an XLEN/8-byte table entry.
If the fetch is successful, the hart
clears the low bit(s) (depending on IALIGN) of the handler address and sets the PC to this handler
address.

[source]
----
/* MRET pseudo-code */
function exception_handler(cur_priv, xret, pc) {
  match (xret) {
...
    MRET =>  {
      /* standard MRET behavior */
      mstatus.MIE   = mstatus.MPIE;
      mstatus.MPIE  = 1;
      cur_priv      = mstatus.MPP;
      ... /* additional standard MRET behavior */

      if (minhv) {
        /* align mepc value to XLEN/8 byte boundary by ignoring low-order bits. */
        let table_addr = mepc & inhv_pc_alignment_mask();
        if (check_fetch_permissions(table_addr) = Addr_OK) {
            next_pc = mem_read(table_addr);
        } else {
            /* take table-fetch horizontal trap */
            mcause.minhv = 1;
            /* other side effects of taking a trap */
        }
      } else { /* Standard MRET behavior - mepc becomes next_pc */
          next_pc = mepc;
          /* mcause.minhv unchanged */
      }
    }
  },

  /* Note, next_pc is passed to fetch unit which will ignore 1 or 2
   LSBs depending on IALIGN, so the masking is not shown above.
   Similarly, permission checks on the ultimate instruction fetch
   are not shown here. */
}
----

NOTE: The {inhv} bit when set at xRET informs hardware to repeat the table fetch using the address in xEPC to obtain the address of the trap handler that is then written to the PC instead of directly writing xEPC to the PC.  One of the goals of this behavior is to avoid complicating the critical code paths for handling virtual memory in the more-privileged layer. The more-privileged layer does not have to distinguish CLIC vector table reads from other forms of page faults and can handle them using exactly the same code.

For permissions-checking purposes, the memory access to retrieve the
function pointer for hardware vectoring is an _implicit_ fetch at the
privilege mode of the interrupt handler, and requires execute
permission; read permission is irrelevant.

NOTE: software vectoring will need vector table read permission.

If there is an access exception on the table fetch, {epc} is written with the faulting address.  {tval} is either set to zero or written with the faulting address.

NOTE: For simpler systems, we do not require that {tval} is written
with the faulting address.  For systems with demand paging, {tval}
should be written with the faulting address to simplify page-fault
handling code.

NOTE: Interrupted context is lost on horizontal traps during table fetch where exceptions are the same privilege mode as the interrupt handler. The interesting case is vertical traps, where a more privileged layer is handling page faults or other synchronous faults for the less privileged mode vector table access. The regular code path in more privileged layer will want to use xtval to determine what bad virtual address to page in, but will not normally restore xtval when returning to faulting context (potentially after some time and other contexts have run). However, it will restore xepc (using x for more privileged mode here) before using xret on normal code path.  This is a rationale for why both {tval} and {epc} are recommended to be written with the faulting address in systems with demand paging.

Memory writes to the vector table require an instruction barrier (_fence.i_) to guarantee that they are visible to the instruction fetch.

==== smclicshv Changes to {epc} CSRs

The {epc} CSRs behave the same in both modes, capturing the PC at
which execution was interrupted.  In CLIC mode, the {epc} CSR additionally may hold the faulting address if there is an access exception on the table fetch during hardware vectoring.

==== smclicshv Changes to `dpc` CSR

For implicit hardware vector table fetches, whether breakpoints trap
on the table read is left as an implementation option. For explicit
loads used in software vectoring, watchpoints operate as normal for
any load.  In CLIC mode, the `dpc` CSR additionally may hold the
faulting address if breakpoints are allowed to trap on the table fetch
during hardware vectoring.  If breakpoints are allowed to trap on the
table read, dret should honor {inhv}.

==== smclicshv Changes to {cause} CSRs

[source]
----
 mcause
 Bits    Field      Description
 XLEN-1 Interrupt    Interrupt=1, Exception=0
    30  minhv        When 1, indicates mepc is the address of a table entry.
                     When 0, indicates mepc is the address of an instruction.
 29:28  mpp[1:0]     Previous privilege mode, same as mstatus.mpp
    27  mpie         Previous interrupt enable, same as mstatus.mpie
 26:24  (reserved)
 23:16  mpil[7:0]    Previous interrupt level
 15:12  (reserved)
 11:0  Exccode[11:0] Exception/interrupt code

 scause with ssclic extension
 Bits    Field        Description
 XLEN-1 Interrupt     Interrupt=1, Exception=0
    30  sinhv        When 1, indicates sepc is the address of a table entry.
                     When 0, indicates sepc is the address of an instruction.
    29  (reserved)
    28  spp           Previous privilege mode, same as sstatus.spp
    27  spie          Previous interrupt enable, same as sstatus.spie
 26:24  (reserved)
 23:16  spil[7:0]     Previous interrupt level
 15:12  (reserved)
 11:0   exccode[11:0] Exception/interrupt code
----

For backwards compatibility in systems supporting both CLINT and CLIC modes, when
switching to CLINT mode the new CLIC {cause} state fields
({inhv} and {pil}) are zeroed.

Note: For now all privilege modes must run in either CLIC mode or all privilege modes must run in non-CLIC mode so switching to CLINT mode from CLIC mode causes {inhv} and {pil} in all privilege modes to be zeroed.

In CLIC mode, when a trap is taken, {cause} has the CLIC format and the {cause} fields are updated.
On the other hand, when not in CLIC mode, {cause} has the CLINT mode format.

==== smclicshv Changes to Next Interrupt Handler Address and Interrupt-Enable CSRs ({nxti})
A read of the {nxti} CSR using CSRR returns either zero, indicating there is no
suitable interrupt to service or that the highest ranked interrupt is
hardware vectored or that the system is not in a CLIC mode, or returns a non-zero
address of the entry in the trap handler table for software vectoring.

NOTE: The {tvt} CSR could be set to memory addresses such that a table
entry was at address zero, and this would be indistinguishable from
the no-interrupt case. Software must avoid doing this for correct utilization
of the {nxti} CSR.

NOTE: Hardware vectored and software vectored interrupts may have different software interfaces.
The assumption is that hardware vectoring would have customized context save/restore finishing with {ret},
whereas software vectoring would use a generic context save/restore and return with a ret instruction.
To support these software interface differences, reads when the highest ranked interrupt is a hardware vectored interrupt return 0.

Pseudo-code for csrrsi rd, mnxti, uimm[4:0] in M mode:
[source]
----
 // clic.priv, clic.level, clic.id represent the highest-ranked interrupt currently present in the CLIC
 mstatus |= uimm[4:0]; // Performed regardless of interrupt readiness.
 if (clic.priv==M && clic.level > mcause.pil && clic.level > mintthresh.th
     && (clicintattr.shv==0) /* filter out hardware vectored interrupts */ ) {
   // There is an available, software vectored interrupt.
   if (uimm[4:0] != 0) {  // Side-effects should occur.
     // Commit to servicing the available interrupt.
     mintstatus.mil = clic.level; // Update hart's interrupt level.
     mcause.exccode = clic.id;   // Update interrupt id in mcause.
     mcause.interrupt = 1;       // Set interrupt bit in mcause.
     if (clicintattr[clic.id][1] == 1) { // If edge interrupt,
       clicintip[clic.id] = 0;           // clear edge interrupt
     }
   }
   rd = VTBASE + XLEN/8 * clic.id; // Return pointer to trap handler entry.
 } else {
   // No suitable pending interrupt or hart not in CLIC mode.
   rd = 0;
 }
 // When a different CSR instruction is used, the update of mstatus and the test
 // for whether side-effects should occur are modified accordingly.
 // When a different privileges xnxti CSR is accessed then clic.priv is compared with
 // the corresponding privilege and xstatus, xintstatus.xil, xcause.exccode are the
 // corresponding privileges CSRs.
----

== CLIC Parameters

Although these are described as parameters, it is understood that hardware implementations may wish to
have a single implementation support different parameterizations of CLIC extensions and may make
these values configurable and initialized prior to CLIC operation.  The smclicconfig extension is provided for that purpose.
However, these parameters should functionally be considered static. If the value of these parameters are changed
during CLIC operation, CLIC behavior is undefined.

=== NVBITS Parameter - Specifying Support for smclicshv Selective Interrupt Hardware Vectoring Extension

The NVBITS Parameter specifies whether
the smclicshv extension is implemented or not.

When NVBITS is 0, the smclicshv extension is not implemented.
In this case, all CLIC interrupts are software vectored and are directed to the common code
at {tvec} register.

When NVBITS is 1, smclicshv extension is implemented.

=== CLICINFO Parameters

The NUM_INTERRUPT 13-bit parameter from 2-4096 that specifies the actual number of maximum interrupt
inputs supported in this implementation. MSIP, MTIP are always included.

The VERSION 8-bit parameter specifies the implementation version of CLIC. The upper
4-bit specifies the architecture version, and the lower 4-bit specifies
the implementation version.

The NUM_TRIGGER 6-bit parameter specifies the number of maximum interrupt
triggers supported in this implementation. Valid values are 0 to 32.

=== CLICINTCTL Parameters

The parameter xNLBITS (MNLBITS, SNLBITS, etc) defines for each privilege mode how many upper bits in
`clicintctl[__i__]` are assigned to encode the interrupt level at that privilege mode,
the remaining lower bits of `clicintctl[__i__]` encode the priority.

The parameter xCLICINTCTLVALUES (MCLICINTCTLVALUES, SCLICINTCTLVALUES, etc.) defines for each
privilege mode the list of legal write values for `clicintctl[__i__]`.

For implementations that choose to implement all 8-bits in the `clicintctl` registers,
xCLICINTCTLVALUES is the list of integers from 0 to 255.

Implementations that assign non-overlapping xCLICINTCTLVALUES ranges to different privilege modes may
be able to implement fewer `clicintattr[__i__].mode`.
For example by limiting MCLICINTCTLVALUES to the set of [240-255] and SCLICINTCTLVALUES to the set of [0-239]
`clicintattr[__i__].mode` reflects an M-mode setting when `clicintattr[__i__].mode` bits 7:4 are all 1s otherwise S-mode.

The smclicconfig extension uses the following scheme for implementations that choose to implement fewer
than 8-bits in the `clicintctl` registers is as follows.
The implemented bits are kept left-justified in the most-significant bits of
each 8-bit `clicintctl[__i__]` register, with the lower unimplemented bits
treated as hardwired to 1.
The parameter `CLICINTCTLBITS` represents the number of implemented bits in this scheme.

If the actual bits assigned or implemented are fewer than 8, then these bits
are left-justified and appended with 1's for the lower missing bits.

Any implemented priority bits are treated as the most-significant bits
of a 8-bit unsigned integer with lower unimplemented bits set to 1.
For example, with one priority bit (`p111_1111`), interrupts can be
set to have priorities 127 or 255, and with two priority bits
(`pp11_1111`), interrupts can be set to have priorities 63, 127, 191,
or 255.

The following table shows how levels are encoded.

[source]
----
CLICINTCTL

num             interrupt levels
bits  encoding  (list of xCLICINTCTLVALUES)
 0    ........                                                        255
 1    L.......                        127,                            255
 2    LL......           63,          127,            191,            255
 3    LLL.....     31,   63,   95,    127,    159,    191,    223,    255
 4    LLLL....  15,31,47,63,79,95,111,127,143,159,175,191,207,223,239,255

 "L" bits are writeable bits in the level specification
 "." bits are non-existent bits for level encoding, treated as 1
----

The smclicconfig extension also has a configuration option nmbits to select the number of supported CLIC privilege modes.
For example, when nmbits is 0, all CLIC interrupts will be M-mode.
Implementations may choose to reallocate interrupt priority-tree control bits that had been assigned to
supporting `clicintattr[__i__].mode` control, to instead add additional control bits to `clicintctl[__i__]` registers.

=== Additional CLIC Parameters

[source]
----
Name           Value Range  Description
CLICANDBASIC   0-1          Implements both CLINT modes too
CLICPRIVMODES  1-3          Number privilege modes: 1=M,2=M/U,3=M/S/U
CLICLEVELS     2-256        Number of interrupt levels including 0
CLICMAXID      12-4095      Largest interrupt ID

INTTHRESHBITS  1-8          Number of bits implemented in {intthresh}.th
CLICMTVECALIGN >= 6         Number of hardwired-zero LSBs in mtvec address.
----
NOTE: These parameters are likely to be available by the general
discovery mechanism that is in development.



== smclicconfig CLIC configuration extension
Hardware implementations may wish to have a single implementation support different parameterizations of clic extensions. This extension defines that programmability.

=== CLIC Configuration Registers

==== CLIC Configuration ({cliccfg} registers)

The CLIC has a single 32-bit global configuration
register per privilege mode, {cliccfg}, that defines
how the `clicintctl[__i__]` registers are subdivided into level and
priority fields.  `mcliccfg` has an additional field that defines interrupt privilege mode configuration.

NOTE: WPRI means "Writes Preserve Values, Reads Ignore Values"
indicating whole read/write fields are reserved for future use. Software
should ignore the values read from these fields, and should preserve
the values held in these fields when writing values to other fields of
the same register. For forward compatibility, implementations that do
not furnish these fields must hardwire them to zero.

[source]
----
  mcliccfg register layout

  Bits    Field
  31:20   reserved (WPRI 0)
  19:16   snlbits[3:0] if ssclic is supported, else reserved (WPRI 0)
  15:6    reserved (WPRI 0)
   5:4    nmbits[1:0]
   3:0    mnlbits[3:0]
----

[source]
----
  scliccfg register layout - dependent on ssclic extension

  Bits    Field
  31:20   reserved (WPRI 0)
  19:16   snlbits[3:0] if ssclic is supported, else reserved (WPRI 0)
  15:0    reserved (WPRI 0)
----

scliccfg is a subset of the mcliccfg register.

NOTE: In a straightforward implementation, reading or writing any field
in scliccfg is equivalent to reading or writing the homonymous
field in mcliccfg.

Detailed explanation for each field are described in the following sections.

[source]
----
Interrupt Mode Table
priv-modes nmbits clicintattr[i].mode  Interpretation
   M          0       xx               M-mode interrupt
   M/S        1       0x               S-mode interrupt
   M/S        1       1x               M-mode interrupt
              2       xx               Reserved
              3       xx               Reserved
----

==== Specifying Interrupt Privilege Mode
The privilege mode of an interrupt is controlled by both `cliccfg.nmbits` and `clicintattr[__i__].mode` as described in the Specifying Interrupt Privilege Mode section below.

The 2-bit `cliccfg.nmbits` WARL field specifies how many bits are
physically implemented in `clicintattr[__i__].mode` to
represent an input __i__'s privilege mode. Although `cliccfg.nmbits` field
is always 2-bit wide, the physically implemented bits in this field
can be fewer than two (depending how many interrupt privilege-modes are supported).

For example, in M-mode-only systems, only M-mode exists so we do not
need any bits to represent the supported privilege-modes. In this case,
no physically implemented bits are needed in the `clicintattr.mode`
and thus `cliccfg.nmbits` is 0 (i.e., `cliccfg.nmbits` can be hardwired to 0).

In M/S-mode systems with the ssclic extension, `cliccfg.nmbits` can be
set to 0 or 1.  If `cliccfg.nmbits` = 0, then all interrupts are treated as
M-mode interrupts.  If the `cliccfg.nmbits` = 1, then a value of 1 in
the most-significant bit (MSB) of a `clicintattr[__i__].mode` register
indicates that interrupt intput is taken in M-mode,
while a value of 0 indicates that interrupt is taken in S-mode.

`clicintattr[__i__].mode` field is writable and is unchanged by writes to `cliccfg`.`nmbits` but the read and implicit read value
is the interpretation as specified in the Interrupt Mode Table above.

NOTE: Bare S-mode (no MMU, satp=0) can be used in microcontrollers to allow hardware delegation of interrupts out of M-mode. Bare S-mode has already been ratified as part of privileged architecture. There are also proposals to add S-mode PMP support to allow an RTOS running in S-mode to isolate itself from tasks running in U-mode.

==== Specifying Interrupt Level

The 4-bit `mcliccfg.xnlbits` WARL fields indicate how many upper bits in
`clicintctl[__i__]` are assigned to encode the interrupt level at that privilege mode.

Although the interrupt level is an 8-bit unsigned integer, the number
of bits actually assigned or implemented can be fewer than 8.
As described above, the number of bits assigned is specified in
`mcliccfg.xnlbits`. The number of bits actually implemented can be derived
from `mcliccfg.xnlbits` and a fixed parameter `CLICINTCTLBITS`
(with value between 0 to 8) which specifies bits implemented for both
interrupt level and priority.

NOTE: The number of available level bits can be determined by subtracting
the number of mode bits from CLICINTCTLBITS.


For example, if the `xnlbits` {gt} `CLICINTCTLBITS`, then the lower bits of
the 8-bit interrupt level are assumed to be all 1s.  Similarly,
if `xnlbits` {lt} 8, then the lower bits of the 8-bit interrupt level are
assumed to be all 1s.

If `xnlbits` = 0, then all interrupts are treated as level 255.

Examples of `mcliccfg` settings:

[source]
----
 CLICINTCTLBITS mnlbits clicintctl[i] interrupt levels
       0         2      ........      255
       1         2      L.......      127,255
       2         2      LL......      63,127,191,255
       3         3      LLL.....      31,63,95,127,159,191,223,255
       4         1      LPPP....      127,255

 "." bits are non-existent bits for level encoding, assumed to be 1
 "L" bits are available variable bits in level specification
 "P" bits are available variable bits in priority specification
----

The number of bits actually implemented in `clicintctl[__i__]` is specified
by a fixed parameter `CLICINTCTLBITS`, which has a value
between 0 to 8. The implemented bits are kept left-justified
in the most-significant bits of each 8-bit `clicintctl[__i__]`
register, with the lower unimplemented bits treated as hardwired to 1.
These control bits are interpreted as level and priority according to
the setting in the CLIC Configuration register (`mcliccfg.xnlbits`).

=== smclicconfig Changes to CLIC CSRs
==== smclicconfig Changes to Interrupt-Level Threshold ({intthresh}) CSRs
If the number of bits actually implemented in the `th` field is less than 8 (e.g. an implementation option when `CLICINTCTLBITS` is less than 8), the number of implemented bits `INTTHRESHBITS` must be greater than `CLICINTCTLBITS` and the implemented bits should be kept left-justified in the most-significant bits of the 8-bit field, with the lower unimplemented bits treated as hardwired to 1.
For example, if `CLICINTCTLBITS` is 1 and `INTTHRESHBITS` is 2, interrupts can be set to level 127 or 255 and {intthresh}.`th` can be set to 63, 127, 191, or 255.

[appendix]
== Interrupt Handling Software
=== Interrupt Stack Software Conventions

The CLIC supports multiple nested interrupt handlers, and each handler
requires some working registers. To make registers available, each
handler typically saves and restores registers from the interrupted
context on a memory-resident stack.  In addition, the memory-resident
stack is used to hold other interrupted context information, such as
{epc} and {cause}, which are required by the {ret} instruction.

The standard RISC-V ABI convention is that stacks grow downwards, and
that memory addresses below the current stack pointer can be
dynamically altered by another agent, such as an interrupt handler.

When interrupts are taken horizontally within the same privilege mode,
the interrupt handler may be able to use the same stack as the
interrupted thread, by allocating a new stack frame below the current
stack pointer.

When interrupts are taken vertically into a higher privilege mode, the
stack pointer must be swapped to a stack within the higher privilege
mode to avoid a security hole.  The {scratch} registers can be used to
hold the stack pointer of a higher-privilege mode while
lower-privilege code is executing, or {scratch} can be used to point
to more extensive thread-local context that might contain a stack
pointer.

[[inline-section,Inlines]]
=== Inline Interrupt Handlers and "Interrupt Attribute" for C

Inline interrupt handlers are small leaf functions that handle simple
interrupts.  To provide easy C coding for inline interrupt handlers,
while reducing register save/restore overhead, we use standard
interrupt attributes, which have the following syntax:

[source]
----
  /* Small ISR to poke device to clear interrupt and increment in-memory counter. */
  void __attribute__ ((interrupt))
  foo (void)
  {
    extern volatile int INTERRUPT_FLAG;
    INTERRUPT_FLAG = 0;
    extern volatile int COUNTER;
  #ifdef __riscv_atomic
    __atomic_fetch_add (&COUNTER, 1, __ATOMIC_RELAXED);
  #else
    COUNTER++;
  #endif
  }
----

The attribute tells the C compiler to use callee-save for all
registers, so the handler has to "pay as it goes" to use registers,
and only save the full caller-save set if it makes a nested regular C
call.  The attribute also tells the C compiler to align the function
entry point on an 8-byte boundary.

[source]
----
   .align 3
      # Inline non-preemptible interrupt handler.
      # Only safe for horizontal interrupts.
   foo:
      addi sp, sp, -FRAMESIZE      # Create a frame on stack.
      sw a0, OFFSET(sp)            # Save working register.
      sw zero, INTERRUPT_FLAG, a0  # Clear interrupt flag.
      sw a1, OFFSET(sp)            # Save working register.
      la a0, COUNTER               # Get counter address.
      li a1, 1
      amoadd.w zero, (a0), a1      # Increment counter in memory.
      lw a1, OFFSET(sp)            # Restore registers.
      lw a0, OFFSET(sp)
      addi sp, sp, FRAMESIZE       # Free stack frame.
      mret                         # Return from handler using saved mepc.
----

With hardware vectoring, inline interrupt handlers can provide very
rapid response for small tasks.

NOTE: The above entire handler executes in 13 instructions.  The
`INTERRUPT_FLAG` store and the `la` require two instructions each to
build up a global address.  A simple pipeline would encounter two
pipeline flushes (on entry and on exit), plus the cycles taken to fetch
the hardware vector entry.

NOTE: This example assumes level-triggered interrupts where `INTERRUPT_FLAG` is cleared at the memory-mapped peripheral. Use of
edge-triggered interrupts and clearing `clicintip[__i__]` via indirect CSR access while same privilege mode mstatus.mie is enabled requires mireg register state to be part of the interrupt handler's overall context state save/restore.

These inline handlers can be used with the CLINT mode as
well as CLIC mode.

To take advantage of hardware preemption within the same privilege mode when in CLIC mode,
inline handlers must save and restore {epc} and {cause} before
enabling interrupts:

[source]
----
   .align 3
      # Inline preemptible interrupt handler.
      # Only safe for horizontal interrupts.
   foo:
      #----- Interrupts disabled on entry ---#
      addi sp, sp, -FRAMESIZE      # Create a frame on stack.
      sw a0, OFFSET(sp)            # Save working register.
      csrr a0, mcause              # Read cause.
      sw a1, OFFSET(sp)            # Save working register.
      csrr a1, mepc                # Read epc.
      csrrsi zero, mstatus, MIE    # Enable interrupts.
      #----- Interrupts enabled ---------#
      sw a0, OFFSET(sp)            # Save cause on stack.
      sw zero, INTERRUPT_FLAG, a0  # Clear interrupt flag.
      sw a1, OFFSET(sp)            # Save epc on stack.
      la a0, COUNTER               # Get counter address.
      li a1, 1
      amoadd.w zero, (a0), a1      # Increment counter in memory.
      lw a1, OFFSET(sp)            # Restore epc
      lw a0, OFFSET(sp)            # Restore cause
      csrrci zero, mstatus, MIE    # Disable interrupts.
      #----- Interrupts disabled  ---------#
      csrw mepc, a1                # Put epc back.
      lw a1, OFFSET(sp)            # Restore a1.
      csrw mcause, a0              # Put cause back.
      lw a0, OFFSET(sp)            # Restore a0.
      addi sp, sp, FRAMESIZE       # Free stack frame.
      mret                         # Return from handler.
      #------------------------------------#
----

NOTE: This version requires 10 more instructions, but reduces the time
a preempting interrupt has to wait from a 13-instruction window to a
6-instruction window (the instruction that disables interrupts can be
preempted before committing).

WARNING: This form cannot be used with CLINT mode,
unless the original interrupt pending signal is cleared before
re-enabling interrupts.

[appendix]
== Calling C-ABI Functions as Interrupt Handlers

An alternative model is where all interrupt handler routines use the
standard C ABI.  In this case, the CLIC would use no hardware
vectoring for the C ABI handlers and instead use a common software
trampoline, which uses the {nxti} instruction to obtain the
trap-handler address.  The code sequence below is annotated with an
explanation of its operation.

NOTE: Example handlers in this specification do not account for the presence of floating-point or vector register
files when saving registers.

=== C-ABI Trampoline Code

[source]
----
  # Example Unix C ABI interrupt trampoline.
  # Only safe for horizontal interrupts.
  # FRAMESIZE should be defined appropriately to hold saved context with ABI-specified alignment.
  # OFFSET should be replaced with individual stack frame locations.
  # Register save/restore pseudo-code should be expanded to individual instructions.

  irq_enter:
  #----Interrupts disabled for 7 + SREGS instructions, where SREGS is number of registers saved. <1>
    addi sp, sp, -FRAMESIZE # Allocate space on stack. <2>
    sw a1, OFFSET(sp)       # Save a1.
    csrr a1, mcause         # Get mcause of interrupted context.
    sw a0, OFFSET(sp)       # Save a0.
    csrr a0, mepc           # Get mepc of interrupt context.
    bgez a1, handle_exc     # Handle synchronous exception. <3>
    sw a0, OFFSET(sp)       # Save mepc.
    sw a1, OFFSET(sp)       # Save mcause of interrupted context.
    sw a2-a7, OFFSET(sp)    # Save other argument registers.
    sw t0-t6, OFFSET(sp)    # Save temporaries.
    sw ra, OFFSET(sp)       # 1 return address <5>
    csrrsi a0, mnxti, MIE   # Get highest current interrupt and enable interrupts.
                            # Will return original interrupt if no others appear. <6>
  #----Interrupts enabled ----------------------- <7>
    beqz a0, exit           # Check if original interrupt vanished. <8>

  service_loop:             # 5 instructions in pending-interrupt service loop.
    lw a1, (a0)             # Indirect into handler vector table for function pointer. <9>
    csrrsi zero, mstatus, MIE # Ensure interrupts enabled. <10>

    jalr a1                 # Call C ABI Routine, a0 has interrupt ID encoded. <11>
                            # Routine must clear down interrupt in CLIC.
    csrrsi a0, mnxti, MIE   # Claim any pending interrupt at level > mcause.pil <12>
    bnez a0, service_loop   # Loop to service any interrupt. <13>

  #--- Restore ABI registers with interrupts enabled --- <14>
    lw ra, OFFSET(sp)       # Restore return address
    lw t0-t6, OFFSET(sp)    # Restore temporaries.
    lw a2-a7, OFFSET(sp)    # Restore other arguments.
    lw a1, OFFSET(sp)       # Get saved mcause,
  exit:                     # Fast exit point.
    lw a0, OFFSET(sp)       # Get saved mepc.

    csrrci zero, mstatus, MIE # Disable interrupts <15>
  #---- Critical section with interrupts disabled -----------------------
    csrw mcause, a1         # Restore previous context.

    lw a1, OFFSET(sp)       # Restore original a1 value.
    csrw mepc, a0           # Restore previous context.

    csrrci a0, mnxti, MIE   # Claim highest current interrupt. <16>
    bnez a0, service_loop   # Go around if new interrupt.

    lw a0, OFFSET(sp)       # Restore original a0 value.
    addi sp, sp, FRAMESIZE  # Reclaim stack space.
    mret                    # Return from interrupt.
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
   handle_exc:
    # ...
    # Perform exception processing with interrupts disabled <4>
    # ...
    addi sp, sp, FRAMESIZE   # Reclaim stack space.
    mret # Return from exception
  #----------------------------------------------------------------------
----

<1> An initial interrupt (II) causes entry to the handler with
interrupts disabled, and {epc} and {cause} CSRs hold values
representing the original interrupted context (OIC), including the PC
in {epc}, the privilege mode in {pp} (visible in both {cause} and
{status}), the interrupt level in {pil} (in {cause}) and the interrupt
enable state in {pie} (visible in both {cause} and {status}).  The
{cause} CSR and the {intstatus} CSRs additionally hold information on
the interrupt to be handled, including `exccode` in {cause} and {il}
in {intstatus}.

<2> The interrupt trampoline needs sufficient space to store the OIC's
caller-save registers as well as its `epc` and `cause` values, which
are saved in a frame on the memory stack to support preemption.  This
routine is M-mode only so does not need to consider swapping stacks
from other privilege modes.  A simple constant bump of the stack
pointer `sp` is sufficient to provide space to store the OIC.

<3> The trap handler could have been entered by a synchronous
exception instead of an interrupt, which can be determined by
examining the sign bit of the returned {cause} value.  If the trap was
for an exception (sign bit zero), the code jumps to exception handler
code while keeping interrupts disabled.

<4> The exception handler code is located here out of line to reduce
performance impact on interrupts.  The main body of the trampoline
only handles interrupts.

<5> If this was an interrupt, the trampoline entry code continues to
save all the caller-save registers to the stack.  This is done with
interrupts disabled, as even if an interrupt arrived with a higher
interrupt level it would still require all registers to be saved.

<6> When {nxti} is read here, the interrupt inputs to the CLIC might
have changed from the time the handler was initially entered.  The
return value of {nxti}, which holds a pointer to an entry in the trap
vector table, is saved in register `a0` so it can be passed as the
first argument to the software vectored interrupt handler, where it
can be used to reconstruct the original interrupt id in the case where
multiple vector entries use a common handler.  There are multiple
cases to consider, all of which are handled correctly by the
definition of {nxti}:

* The II is still the ranking interrupt (no change).  In this case, as
the level of the II will still be higher than `pil` from the OIC, {il}
and `exccode` will be rewritten with the same value that they already
had (effectively unchanged), and {nxti} will return the table entry
for the II.

* The II has been superseded by a higher-level non-SHV interrupt.  In
this case, {il} will be set to the new higher interrupt level,
`exccode` will be updated to the new interrupt id, and {nxti} will
return the vector table entry for the new higher-level interrupt.  The
OIC is not disturbed, retaining the original `epc` and the original
`pil`.  This case reduces latency to service a more-important
interrupt that arrives after the state-save sequence was begun for the
less-important II.  The II, if still pending-enabled, will be serviced
sometime after the higher-level interrupt as described below.

* The II has been superseded by a higher-priority non-SHV interrupt at
the same level.  This operates similarly to the previous case, with
`exccode` updated to the new interrupt id.  Because the lower-priority
interrupt had not begun to run its service routine, this optimization
preserves the property that interrupt handlers at the same interrupt
level but different priorities execute atomically with respect to each
other (i.e., they do not preempt each other).

* The II has disappeared and a lower-ranked non-SHV interrupt, which
has interrupt level greater than the OIC's `pil` is present in CLIC.
In this case, the {il} of the handler will be reduced to the
lower-ranked interrupt's level, `exccode` will be updated with the new
interrupt id, and {nxti} will return a pointer to the appropriate
handler in table.  In this case, the new lower-ranked interrupt would
still have caused the original context to have been interrupted to run
the handler, and the disappearing II has simply caused the
lower-ranked interrupt's entry and state-save sequence to begin
earlier.

* The II has disappeared and either there is no current interrupt from
the CLIC, or the current ranking interrupt is a non-SHV interrupt with
level lower than {pil}.  In this case, the {il} and `exccode` are not
updated, and 0 is returned by {nxti}.  The following trampoline code
will then not fetch a vector from the table, and instead just restore
the OIC context and `mret` back to it.  This preserves the property
that the OIC completes execution before servicing any new interrupt
with a lower or equal interrupt level.

* The II has been superseded by a higher-level SHV interrupt.  In this
case, the {il} and `exccode` are not updated, and 0 is returned by
{nxti}.  Once interrupts are reenabled for the following instruction,
the hart will preempt the current handler and execute the vectored
interrupt at a higher interrupt level using the function pointer
stored in the vector table.

<7> Interrupts are now enabled.  If a higher-level SHV interrupt had
arrived while interrupts were disabled, then the current handler will
be preempted and execution starts at the SHV handler address.  If a
software vectored higher-level interrupt arrives now, it will also preempt
the current handler and begin a nested state-save sequence at the
handler entry point `irq_enter`.

<8> The branch checks if the II disappeared or if a higher priority
SHV at the same level appeared, in which case the current handler
returns to the OIC.  As most registers have not been touched, the
routine can skip past most of the register restore code.  This
preserves the property that interrupts (SHV or non-SHV) at the same
level do not preempt each other.

<9> The value returned by {nxti} is used to index the vector table and
return the function pointer.

<10> This `csrrsi` instruction enables interrupts and is redundant
when proceeding sequentially from the first {nxti} read (6) or if
looping back from the end of the `service_loop` (13).  However, it is
required on the backward path from (16) to re-enable interrupts to
allow preemption.  It is scheduled after the table lookup to use what
will often be a load-use delay slot.

<11> The `jalr` instruction actually calls the C ABI function that
implements the handler.  Interrupts are enabled at this point, so the
C function can be preempted at any time by an interrupt with a higher
level than current {il}.

<12> Once the handler returns, another read of {nxti} checks if there
are any more interrupts to service.  Interrupts remain enabled.  The
`csrrsi` includes a redundant set of the {ie} interrupt enable to
force the CSR instruction to update CSR state.  Only non-SHV
interrupts with a level greater than `pil` will be serviced in this
loop.  Note that {il} can decrease from its current value on the
{nxti} read.  {il} should not increase in this code, as interrupts are
enabled here and if a higher-level interrupt was ready, it should have
preempted this instruction.

<13> If there was another appropriate interrupt to service, the code
loops back to perform the next handler call.  The `service_loop` only
contains 5 instructions, allowing multiple back-back interrupts to be
handled without saving and restoring contexts.  On a simple pipeline
with a one-cycle load-use penalty, single-cycle CSR access, and a
one-cycle taken-branch penalty, the service loop can initiate a new
interrupt service with only 7 clock cycles of overhead per handler
call.

<14> This instruction sequence restores the OIC.  Interrupts are still
enabled, so preemption is allowed during this restore.

<15> Interrupts are disabled for the final steps of restoring the OIC,
which requires loading `mcause` and `mepc` from the stacked values,
and recovering the final register values from the OIC.

<16> A final read of {nxti} is performed before returning, to reduce
the maximum interrupt latency.  If a suitable interrupt arrives, it
can be serviced without saving context.  The `csrrci` instruction
includes a redundant clear of the interrupt enable bit to ensure the
CSR state updates occur.  Interrupts must stay disabled until after
the following branch to maintain the critical section used to restore
the OIC in the case that there is no interrupt to service.

The following table summarizes the machine state changes that occur at
the first {nxti}:

[%autofit]
[source]
----
IC    at entry |->           |       at first nxti (6)
il     CLIC                  |    CLIC
    level id V |->  mil code | level id V    |-> mil code rd
p    e<=p  ? ? |->           |                               # Shouldn't happen
p    e>p   i 0 |->   e    i  |   f>p  j 0    |->  f    j   T # Same or superseded interrupt
p    e>p   i 0 |->   e    i  |   f>p  j 1    |->  e    i   0 # Ignore hardware vectored interrupt
p    e>p   i 0 |->   e    i  |   f<=p j ?    |->  e    i   0 # Interrupt disappeared
p    e>p   i 1 |->   e    i  |                               # Won't be in trampoline
----

=== Revised C-ABI for Embedded RISC-V

The overhead to save and restore registers in the interrupt trampoline
can be reduced with a new embedded ABI that reduces the number of
caller-save registers.  Work is underway to define such an ABI, but it
is likely to require around 7 integer registers to be saved/restored
instead of 16 in the standard Unix ABI.

This will result in 18 instructions executed in the trampoline code
before arriving at the correct handler function, of which 9 are stores
(saving 7 registers plus 2 words for {epc} and {cause}).

=== Analysis of Worst-Case Interrupt Latencies for C-ABI Trampoline

The following analysis assumes a system with M-mode only and a new
embedded ABI requiring 7 caller-save registers to be saved and
restored.  For cycle timings, we assume a simple 3-stage pipeline that
has a one-cycle taken-branch or pipeline flush penalty, a one-cycle
load-use delay, and single-cycle CSR access.  This simple model
ignores effects from contention in shared memory structures, or
pipeline hazards from continuing long-latency operations in the
interrupted code.

There are several cases to consider for the worst-case latency for a
C-ABI higher-level interrupt handler that preempts lower-level code.

If an interrupt arrives while interrupts are enabled, either inside or
outside of a current handler, the hart will jump directly to
`irq_enter` at the new interrupt level.  The system must flush the
execution pipeline and then execute 18 instructions, the last of which
is the `jalr` that calls the handler function.  These 18 instructions
execute in 20 cycles using the simple pipeline model.

When interrupts are disabled, the arriving preempting handler could be
delayed.  If the preempting interrupt arrives while interrupts are
disabled during the initial entry sequence (1)--(6), there will be no
additional delay as the first {nxti} instruction (6) will cause the
higher-level interrupt handler to be invoked, replacing the original
interrupt cause.

If the preempting interrupt arrives after interrupts are disabled (15)
but before {nxti} is read (16), then the trampoline will observe the
new interrupt during execution of the {nxti} read (16), and take a
short branch back to the `service_loop`, which is lower latency than
the interrupt-disabled case.

If the preempting interrupt arrives after the read of {nxti} commits
(16), then the interrupt has to wait an additional 4 instructions
until the `mret` reenables interrupts, at which point the interrupt
will be taken and the handler entered at `irq_enter`.  In the simple
pipeline model, `mret` adds an additional pipeline flush cycle, so the
preemption latency is 20+5 cycles, which represents the worst-case for
a preempting C-ABI interrupt handler.

[appendix]
== Interrupt-Driven C-ABI Model

For many embedded systems, after initialization, essentially all code
is run in response to an interrupt, interrupt levels are used to
prioritize execution of different tasks, and the hart should
sleep in between interrupt events to save energy.

The following code can be used as the background code that runs at
interrupt level 0 and which when there is no active work to do, puts
the hart to sleep with no active context, waiting for an
interrupt using the `wfi` instruction.  The code is entered at the
`enter_loop` location and never returns directly.

[source]
----
    # Source code for interrupt-driven model background code.
sleep:
    csrrci zero, mstatus, MIE # Disable interrupts.  <1>
    wfi                     # Hart waits for next interrupt event.
    csrrsi a0, mnxti, MIE   # Gather interrupt details, and enable interrupts. <2>
    beqz a0, sleep          # Go back to sleep if no interrupt (will be preempted if SHV). <3>

service_loop: <4>
    lw a1, (a0)             # Get handler address.
    csrrsi zero, mstatus, MIE # Enable interrupts
    jalr a1                 # Call C-ABI handler routine
    csrrsi a0, mnxti, MIE   # Claim any pending interrupt at level > 0
    bnez a0, service_loop   # Loop to service any interrupt.

    # This is also entry point to begin sleeping.
enter_sleep: <5>
    la a0, sleep
    csrci zero, mstatus, MIE  # Disable interrupts.
    #--- Interrupts disabled
    csrw mepc, a0           # Initialize mepc to point to sleep
    li a0, (MMODE)<<PP|(0)<<PIL|(1)<<PIE
    csrw mcause, a0         # Initialize mcause to have pp=M, pil=0, pie=1
    mret                    # Jump to sleep at level 0 with interrupts enabled.
    #--- Interrupts enabled
----

<1> The `sleep` loop is used to stall the hart while waiting for
work and is always entered at interrupt level 0.  Interrupts are
disabled, then a `wfi` is executed.  The `wfi` will stall the
hart until some event occurs.  When an event, including an
interrupt occurs, the `wfi` retires.  Because interrupts are disabled,
the hart does not jump to an interrupt handler but instead executes
the next instruction, avoiding context save/restore overhead.

<2> The read of {nxti} will determine if any non-SHV interrupt is
available, and if so return a pointer to the table entry.  Interrupts
are enabled by this instruction to allow SHV interrupts to be taken
via preemption.

<3> The value in `a0` checked by the branch can be zero for two
reasons. Either there was no interrupt detected or an SHV interrupt
was detected.  If there was no interrupt, the branch loops back to put
the hart to sleep.  Interrupts are enabled, so any SHV interrupt
(which all have higher interrupt level than the current interrupt
level of 0) will preempt the branch's execution and call the SHV
handler.  Once the SHV handler returns, the branch will resume and
cause execution to return back to the `sleep_loop`.

<4> The service loop is identical to that in the C-ABI interrupt
handler, except that the previous interrupt level is 0, so all pending
interrupts will be serviced in the loop before the loop exits.
Interrupts are enabled, so preemption is allowed for both C-ABI
trampoline and SHV interrupts.  When an SHV interrupt at the same or
lower interrupt level is the next to be serviced, the {nxti}
instruction will return 0 causing execution to drop out of the loop.
The following code will reinitialize the hart's interrupt level to 0,
and disable interrupts for one instruction, to ensure the SHV
interrupt will be taken.

<5> This code initializes `mepc` and `mcause` then uses an `mret` to
jump to the `sleep` loop while simultaneously resetting interrupt level
to 0 and enabling interrupts.  This is also the entry point to
initiate interrupt-driven execution.  Interrupts are enabled to allow
SHV interrupts to preempt execution on the first instruction in
`sleep` (which disables interrupts again).

This code does not increase worst-case interrupt latency over that of
the C-ABI trampoline.

[appendix]
== Alternate Interrupt Models for Software Vectoring

Platforms may not implement the sclicshv extension, in which case, hardware vectoring can be emulated
by a single software trampoline present at `NBASE` using the separate
vector table address in {tvt}.  There are several different software
approaches possible, depending on system requirements and constraints,
as detailed in following subsections.

===  `gp` Trampoline to Inline Interrupt Handlers in Single Privilege Mode

Where interrupts are known to be generated and handled in a single
privilege mode (i.e., M-mode only systems, or S-mode interrupt
handlers), a three-instruction sequence using the `gp` register to
hold the handler address can be used to indirect to an inline
interrupt handler of the type described in <<Inlines>>.

[source]
----
    # Software vectored interrupt servicing.
    # Only safe for horizontal interrupts.
    # Must be placed three instructions back from gp.
irq_enter:
    csrrci gp, mnxti, MIE   # Overwrite gp, keep interrupts disabled.
    beqz gp, handle_exc     # Encountered exception.
    jalr gp, gp             # Recreate gp and jump to handler.
gp:                         # Must be right before system's gp location.
    # ... gp data section

    # Must be within range of beqz instruction.
handle_exc:
    # Has to recreate gp.
----

The three-instruction sequence relies on the `jalr` instruction
recreating the value in the `gp` register, which is a known constant
pointing into the middle of the global data area, by placing the
`jalr` directly before the `gp` location in memory.  The routine
jumped to by the `jalr` does not return via a `j ra` but instead ends
with an `mret`.

NOTE: This constraint on memory layout might not always be possible,
particularly if the system does not allow placing executable memory
right next to read-write memory, for example if the system does not
allow a protection boundary to be placed at 'gp' and if executable
code must not be writeable.

The code can be used with preemptible inline interrupt handlers.

=== Trampoline for Preemptible Inline Handlers

This section describes a more general software-trampoline scheme for
calling preemptible inline handlers, which factors out the
{epc}/{cause} save code into the trampoline, and which uses a
different interrupt handler calling convention.

The interrupt handlers for this scheme have a calling convention where
there is one caller-save argument register `a0` that passes in the
handler address to distinguish different interrupt inputs, and one
temporary register `a1` that is also caller-save.  These two registers
had to be saved already by the trampoline. All other registers are
callee-save, except for the return address `ra`.  The handler normally
returns with a regular `j ra`.

[source]
----
  # Example handler with new calling convention.
  # Only safe for horizontal interrupts.
  # Handlers have two temporary registers available, a0, a1.
handler_example:
  sw zero, INTERRUPT_FLAG, a0     # Clear interrupt flag.
  la a0, COUNTER                # Get counter address.
  li a1, 1                      # Increment value.
  amoadd.w zero, (a0), a1         # Bump counter.
  j ra

  # Interrupt trampoline code.
irq_enter:
  #----- Interrupts disabled on entry ---#
  addi sp, sp, -FRAMESIZE      # Create a frame on stack.
  sw a0, OFFSET(sp)            # Save working register.
  csrr a0, mcause              # Read cause.
  bgez a0, handle_exc          # Handler exception.
  sw a1, OFFSET(sp)            # Save working register.
  csrr a1, mepc                # Read epc.
  sw a0, OFFSET(sp)            # Save cause
  csrrsi a0, mnxti, MIE        # Get highest interrupt, enable interrupts.
  #----- Interrupts enabled ---------#
  beqz a0, exit
  sw a1, OFFSET(sp)            # Save epc.
  sw ra, OFFSET(sp)            # Save return address.

irq_loop:
  lw a1, (a0)                  # Get function pointer.
  jalr a1                      # Call handler code.
  csrrsi a0, mnxti, MIE        # Get any next interrupt.
  bnez a0, irq_loop            # Service interrupt if any.

  lw ra, OFFSET(sp)            # Restore ra.
  lw a1, OFFSET(sp)            # Get epc.
exit:
  lw a0, OFFSET(sp)            # Get cause.
  csrrci zero, mstatus, MIE      # Disable interrupts.
  #----- Interrupts disabled  ---------#
  csrw mepc, a1                # Put epc back.
  lw a1, OFFSET(sp)            # Restore a1.
  csrw mcause, a0              # Put cause back.
  lw a0, OFFSET(sp)            # Restore a0.
  addi sp, sp, FRAMESIZE       # Free stack frame.
  mret                         # Return from handler.
  #------------------------------------#

handle_exc:
  # ...
  # Handle exception with interrupts disabled.
  # ...
  addi sp, sp, FRAMESIZE  # Deallocate stack space
  mret                    # Return from handler.
  #------------------------------------#
----

This interrupt handler can be used together with the `wfi` sleep
background routine shown above.

[appendix]
== Managing Interrupt Stacks Across Privilege Modes

Interrupt handlers need to have a place to save the previous context's
state to provide working registers for the handler code.  If a handler
can be entered from a lower-privilege mode, a pointer to some safe
memory for the context save must be swapped in at entry to the
higher-privileged handler to avoid security holes. The RISC-V
privileged architecture provides the {scratch} register to hold this
information for a higher-privilege mode while executing in a
lower-privilege mode.  For the following discussion and code examples,
the assumption is that {scratch} is used to hold the
higher-privilege-mode stack pointer but other software conventions are
possible (e.g., {scratch} points to a thread context block).

Existing RISC-V ABIs allow addresses immediately below the stack
pointer to be overwritten by interrupt service routines.  The current
stack pointer in `sp` (`x2`) should be swapped with {scratch} whenever
a handler is entered from a lower-privilege mode, but should not be
swapped if entered from another handler in the same privilege mode,
including when preempting an existing interrupt handler.  At exit from
a handler, the lower-privilege stack pointer should be swapped back in
if transitioning back to the lower-privilege mode.

=== Software Privileged Stack Swap

In this convention, when code is running in a lower privilege mode,
{scratch} holds the stack pointer for the higher-privilege mode.  When
the higher-privilege mode is entered, {scratch} is set to zero to
signal to any preempting handlers that the stack pointer has already
been swapped.

The old stack pointer is saved to new stack frame before new frame is
created by bumping stack pointer, but this is done with interrupts
disabled.

[source]
----
  # This code is out of line to reduce worst-case preemption latency.
enter_M:
  sw sp, OFFSET-FRAMESIZE(sp)  # Save previous mscratch (M-mode sp)
  addi sp, sp, -FRAMESIZE      # Create a frame on stack.
  sw a0, OFFSET(sp)            # Save a register.
  csrrw a0, mscratch, 0        # Get previous sp, and zero mscratch.
  sw a0, OFFSET(sp)            # Save previous sp (U-mode sp)
  j  continue                  # Jump back into handler

irq_enter:
  #----- Interrupts disabled on entry ---#
  csrrw sp, mscratch, sp       # Swap stack pointer and scratch.
  bnez sp, enter_M             # Check if entering M-mode
  csrrw sp, mscratch, sp       # Already in M-mode, so swap sp back.
  sw sp, OFFSET-FRAMESIZE(sp)  # Save previous sp to stack.
  addi sp, sp, -FRAMESIZE      # Create a frame on stack.
  sw zero, OFFSET(sp)            # Save previous mscratch to stack (was zero).
  sw a0, OFFSET(sp)            # Save a register.
continue:
  csrr a0, mcause              # Read cause.
  bgez a0, handle_exc          # Handle exception.
  sw a1, OFFSET(sp)            # Save working register.
  csrr a1, mepc                # Read epc.
  sw a0, OFFSET(sp)            # Save cause
  csrrsi a0, mnxti, MIE        # Get highest interrupt, enable interrupts.
  #----- Interrupts enabled ---------#
  beqz a0, exit
  ...

  #---- Critical section with interrupts disabled -----------------------
    ...

    lw a0, OFFSET(sp)          # Get previous mscratch.
    csrw mscratch, a0          # Put back in mscratch.
    lw a0, OFFSET(sp)          # Restore original a0 value.
    lw sp, OFFSET(sp)          # Restore previous sp
    mret                       # Return from interrupt.
  #-----------------------------------------------------------------------
----

This code can be used in a secure model where user-level code has one
stack, and all interrupts and exceptions are handled on a second
M-mode-only stack.  In addition, background non-handler code in M-mode
can either use the same M-mode stack as the interrupt handler, or a
separate M-mode stack.  The only difference is in the value held in
{scratch} while the M-mode background thread is running (either 0 to
indicate use the existing stack pointer in `sp` or non-zero to
indicate this stack pointer should be used in the handler.

The above software scheme adds 7 instructions to the interrupt code
path when preempting the same privilege mode, and adds an additional 6
instructions (13 total including two taken branches) for interrupts
from a lower-privilege mode into a higher-privileged mode.

==== Stack Swap Example Code

Interrupt handlers running in the lowest privilege mode do not need to
swap stack pointers, as they will only be entered by a horizontal
interrupt from the same privilege mode.  In systems with multiple
privilege modes, handlers running in higher privilege modes must
account for vertical interrupts taken from a lower privilege mode (in
which case the stack pointer must be swapped) as well as horizontal
interrupts from the same privilege mode.

[source]
----
    # Example of inline interrupt with stack swapping.
   .align 3
   foo:
      csrrw sp, mscratchcsw, sp    # Conditionally swap in stack pointer.
      addi sp, sp, -FRAMESIZE      # Create a frame on stack.
      sw s0, OFFSET(sp)            # Save working register.
      sw zero, INTERRUPT_FLAG, s0    # Clear interrupt flag.
      sw s1, OFFSET(sp)            # Save working register.
      la s0, COUNTER               # Get counter address.
      li s1, 1
      amoadd.w zero, (s0), s1        # Increment counter in memory.
      lw s1, OFFSET(sp)            # Restore registers.
      lw s0, OFFSET(sp)
      addi sp, sp, FRAMESIZE       # Free stack frame.
      csrrw sp, mscratchcsw, sp    # Conditionally swap out stack pointer.
      mret                         # Return from handler using saved mepc.
----

NOTE: This example assumes level-triggered interrupts where `INTERRUPT_FLAG` is cleared at the memory-mapped peripheral. Use of
edge-triggered interrupts and clearing `clicintip[__i__]` via indirect CSR access while same privilege mode mstatus.mie is enabled requires mireg register state to be part of the interrupt handler's overall context state save/restore.

[source]
----
    # Example of inline preemptible interrupt with stack swapping.
   .align 3
   foo:
      #----- Interrupts disabled on entry ---#
      csrrw sp, mscratchcsw, sp    # Conditionally swap in stack pointer.
      addi sp, sp, -FRAMESIZE      # Create a frame on stack.
      sw s0, OFFSET(sp)            # Save working register.
      sw s1, OFFSET(sp)            # Save working register.
      csrr s0, mcause              # Read cause.
      csrr s1, mepc                # Read epc.
      csrrsi zero, mstatus, MIE      # Enable interrupts.
      #----- Interrupts enabled ---------#
      sw s0, OFFSET(sp)            # Save cause on stack.
      sw zero, INTERRUPT_FLAG, s0    # Clear interrupt flag.
      sw s1, OFFSET(sp)            # Save epc on stack.
      la s0, COUNTER               # Get counter address.
      li s1, 1
      amoadd.w zero, (s0), s1        # Increment counter in memory.
      lw s1, OFFSET(sp)            # Restore epc
      lw s0, OFFSET(sp)            # Restore cause
      #----- Interrupts disabled  ---------#
      csrrci zero, mstatus, MIE      # Disable interrupts.
      csrw mepc, s1                # Put epc back.
      csrw mcause, s0              # Put cause back.
      lw s1, OFFSET(sp)            # Restore s1.
      lw s0, OFFSET(sp)            # Restore s0.
      addi sp, sp, FRAMESIZE       # Free stack frame.
      csrrw sp, mscratchcsw, sp    # Conditionally swap out stack pointer.
      mret                         # Return from handler.
      #------------------------------------#
----

[source]
----
  # Example C-ABI interrupt trampoline with stack swapping.

  irq_enter:
  #----
    csrrw sp, mscratchcsw, sp # Conditionally swap in stack pointer.
    addi sp, sp, -FRAMESIZE   # Allocate space on stack.
    # ...
    # Everything else same as above.
    # ...
    addi sp, sp, FRAMESIZE    # Reclaim stack space.
    csrrw sp, mscratchcsw, sp # Conditionally swap back stack pointer.
    mret                      # Return from interrupt.
  #-----------------------------------------------------------------------
  #-----------------------------------------------------------------------
   handle_exc:
    # ...
    # Perform exception processing with interrupts disabled
    # ...
    addi sp, sp, FRAMESIZE    # Reclaim stack space.
    csrrw sp, mscratchcsw, sp # Conditionally swap back stack pointer.
    mret                      # Return from exception
  #----------------------------------------------------------------------
----

In all cases, conditionally swapping the stack to account for
potential privilege-mode changes adds two extra instructions to all
interrupt handlers.

[appendix]
== CLIC Interrupt ID ordering recommendations

The specific numbering of interrupts is defined by the platform.  A
platform definition will often be based on a specific RISC-V ISA
profile, where RISC-V ISA profiles specify a common set of ISA choices
that capture the most value for most users to enable software
compatibility.

Certain RISC-V profiles may include the CLIC as an option.

Four different CLIC interrupt ID orderings are enumerated below for
ease of reference in profile specifications.

=== CLIC-mode interrupt-map for systems retaining interrupt ID compatible with CLINT mode:

The CLINT-mode interrupts retain their interrupt ID in CLIC mode.
The `clicintattr` settings are now used to delegate these interrupts as
required.

We recommend allocating an edge-triggered CLIC software interrupt bit
(`csip`) with the lowest number (16) among the local interrupts to
provide support for a local background interrupt thread, e.g. context
switching.  By placing the `csip` interrupt at the lowest number among
local interrupts, we avoid requiring another interrupt level to
ensure this only runs when there are no other interrupts.

The existing CLINT software interrupt bits are primarily intended for
inter-hart interrupt signaling, and so are retained for that purpose.
The software interrupts can have their priority changed using their
`clicintctl` setting.

CLIC interrupt inputs are allocated IDs beginning at interrupt ID 17.
Any fast local interrupts that would have been connected at interrupt
ID 16 and above should now be mapped into corresponding inputs of the
CLIC.


[source]
----
ID  Interrupt   Note

 0  usip        User software Interrupt
 1  ssip        Supervisor software Interrupt
 2  reserved
 3  msip        Machine software interrupt

 4  utip        User timer interrupt
 5  stip        Supervisor timer interrupt
 6  reserved
 7  mtip        Machine timer interrupt

 8  ueip        User external (PLIC/APLIC) interrupt
 9  seip        Supervisor external (PLIC/APLIC) interrupt
10  reserved
11  meip        Machine external (PLIC/APLIC) interrupt

12  reserved
13  reserved
14  reserved
15  reserved

16  csip        CLIC software interrupt
17+ inputs      CLIC local inputs
----

In CLINT mode, as stated in the RISC-V privilege specification, each
individual bit in CSR register {ip} may be software writable or may be
software read-only. When bit _i_ in {ip} is writable, a pending
interrupt _i_ can be cleared by writing `0` to this bit. STIP is
writable in `mip`, and may be written by M-mode software to deliver
timer interrupts to S-mode.

However, in CLIC mode, {ip} bits cannot be updated in software when
they are in level-sensitive mode.  One possible equivalent
implementation to deliver timer interrupts would be to hardwire the
STIP input to 0 and then M-mode software can deliver timer interrupts to
S-mode by setting `clicintattr[stip].trig` to `00`
(positive-edge-triggered) and writing `clicintip[stip]` to `1`.

The following optional recommendations remove unused interrupt inputs
and compress the map to simplify hardware implementations.

=== CLIC-mode interrupt-map recommendation for single-hart systems with PLIC/APLIC:

[source]
----
ID  Interrupt
0   S-mode software interrupt
1   S-mode timer interrupt
2   S-mode external (PLIC/APLIC) interrupt
3   M-mode software interrupt
4   M-mode timer interrupt
5   M-mode external (PLIC/APLIC) interrupt
6+  local
----

=== CLIC-mode interrupt-map recommendation for single-hart M/S/U systems with no PLIC/APLIC:

[source]
----
ID  Interrupt
0   S-mode software interrupt
1   S-mode timer interrupt
2   M-mode software interrupt
3   M-mode timer interrupt
4+  other
----

=== CLIC-mode interrupt-map recommendation for single-hart M-mode only or M/U mode
systems without N extension and no PLIC/APLIC:

[source]
----
ID  Interrupt
0   M-mode software interrupt
1   M-mode timer interrupt
2+  other
----



[[bibliography]]
== Bibliography

[CD3600] Interrupt and interrupt mask register with interrupt address based on interrupt number.  Control Data 3600 Computer System Reference Manual, Chapter IV - Interrupt System http://bitsavers.org/pdf/cdc/3x00/48bit/3600/60021300E_3600_SysRef_Sep64.pdf

[BiiN] Interrupt preemption, checking pending interrupts before returning, adjusting current priority level (modpc).  Chapter 12. Interrupts http://bitsavers.org/pdf/biin/BiiN_CPU_Architecture_Reference_Man_Jul88.pdf

[WE_32100] Intermediate context switching.  Chapter 4.4.1 Context Switching Strategy http://www.bitsavers.org/pdf/westernElectric/WE_32100_Microprocessor_Information_Manual_Jan85.pdf
